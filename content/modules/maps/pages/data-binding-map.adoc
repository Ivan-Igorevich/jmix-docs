= 1. Creating a Map Binding to Data

In this chapter, you will create:

* The `LocationType` enumeration.
* The `Location` entity with the `GeoPoint` attribute type.
* CRUD views with a map on the `Location.detail` view.

[[entity-and-views-creation]]
== Creating Location Entity and Views

First let's create a `LocationType` enumeration with two values: `Office` and `Coworking`. The detailed steps for creating enumerations are in the xref:tutorial:enumerations.adoc[Using Enumerations] section of Tutorial.

image::enumeration-location-type.png[align="center", width="591"]

Then create the `Location` entity. The detailed steps for creating entities are in the xref:tutorial:simple-crud.adoc[Simple CRUD] section of Tutorial.

Select the *Traits → Versioned* checkbox in the *New JPA Entity* dialog:

image::new-location-entity-dialog.png[align="center", width="493"]

The `Location` entity has the following attributes:

* `city` with `String` type. Select the *Mandatory* checkbox.
* `address` with `String` type. Select the *Mandatory* checkbox.
* `type` with `LocationType` enumeration type.
* `building` with `GeoPoint` type. Select the *Mandatory* checkbox:
+
image::geo-point-attribute.png[align="center", width="862"]

Define the `address` attribute for generating an xref:studio:entity-designer.adoc#creating-instance-name[instance name].

Switch to the *Text* tab of *Entity designer* and add the `@Geometry` annotation to the `building` attribute.

image::location-entity-text.png[align="center", width="843"]

Create CRUD views for the `Location` entity. The detailed steps for creating entity list and detail views are in the xref:tutorial:simple-crud.adoc#create-views[Creating CRUD Views] section of Tutorial.

Accept the suggested values on the all steps of the view creation wizard.

Studio will generate two views: `Location.list` and `Location.detail` and open their source code.

[[adding-map]]
== Adding Map on View

Find `location-detail-view.xml` in the *Jmix* tool window and double-click it. The view designer appears:

image::location-detail-view.png[align="center", width="1318"]

As you can see, the `textField` component is used to display `building`.

To display a map on the screen, you need to add `geoMap` UI component in the XML descriptor.

Place the cursor after the `formLayout` element.

Click *Add Component* in the actions panel, find the `GeoMap` item and double-click it.

image::adding-map.png[align="center", width="1136"]

The new `map` element will be created under the `formLayout` element in the *Jmix UI* hierarchy panel and in XML. Set the `id`, `height` and `width` attributes as shown below.

[source,xml,indent=0]
----
<maps:geoMap id="map" height="100%" width="100%"/>
----

[[adding-tile-layer]]
=== Adding Tile Layer with OsmSource

We will use a raster layer as a base background layer of a map. Let’s use `OsmSource` - predefined source for showing https://wiki.openstreetmap.org[OpenStreetMap^] tiles.

Select `map` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *Layers -> TileLayer* in the drop-down list.

image::add-tile-layer.png[align="center", width="331"]

Select `maps:tile` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *OsmSource* in the drop-down list.

image::add-osmsource.png[align="center", width="898"]

Let's run the application to see the new feature in action.

Click the *Debug* button (image:start-debugger.svg[]) in the main toolbar.

Before running the application, Studio checks the difference between the project data model and the database schema. As long as you have created a new entity, Studio generates a Liquibase changelog for the corresponding changes in the database (creating the `LOCATION` table):

image::changelog-location.png[align="center", width="1036"]

Click *Save and run*.

Studio will execute the changelog against your database. After that, Studio builds and runs the application:

image::run-app.png[align="center", width="1101"]

When the application is ready, open `++http://localhost:8080++` in your web browser and log in to the application with `admin` / `admin` credentials.

Click on the `Locations` item in the `Application` menu. You will see the `Location.list` view. Click *Create*. The `Location.detail` view will open:

image::location-detail1.png[align="center", width="1134"]

[[setting-map-view]]
=== Setting Map View

By default, the `geoMap` component displays a world map with initial geographical center `(0,0)`.

We will use the map view to set the location of the map to display.

Select `map` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *MapView* in the drop-down list.

image::add-map-view.png[align="center", width="372"]

Set the `centerY` attribute:

[source,xml,indent=0]
----
<maps:mapView centerY="51.0"/>
----

Select `maps:mapView` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *Extent* in the drop-down list. Set the `minX`, `minY`, `maxX` and `maxY` attributes as shown below.

[source,xml,indent=0]
----
<maps:extent minX="-15.0"
             minY="30.0"
             maxX="40.0"
             maxY="60.0"/>
----

The extent constrains the view, in other words, nothing outside of this extent can be visible on the map.

Launch the application and check the new feature in action.

[[adding-data-layer]]
=== Adding Vector Layer with DataVectorSource

To work with geo-objects, we will add a vector layer.

Select `maps:layers` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *VectorLayer* in the drop-down list. Set the `id` attribute: `id="vectorLayer"`.

Let's use `DataVectorSource`. It supports data binding with Jmix data containers.

Select `vectorLayer` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *DataVectorSource* in the drop-down list. Set the `dataContainer` attribute for it:

[source,xml,indent=0]
----
<maps:vector id="vectorLayer">
    <maps:dataVectorSource dataContainer="locationDc"/>
</maps:vector>
----

Let's check out: the full description of our map looks like this:

[source,xml,indent=0]
----
include::example$/maps-ex1/src/main/resources/com/company/onboarding/view/location/location-detail-view.xml[tags=geoMap]
----

[[saving-coordinates]]
== Saving Coordinates to the Building Attribute

When HR manager creates a location, he clicks on a place on the map, which is saved in the `Location` entity as a `Point` with coordinates.

So let's add a `ClickEvent` for our map.

Select `map` in the *Jmix UI* hierarchy panel or in the view XML descriptor, switch to the *Handlers* tab and create a `MapClickEvent` handler method:

image::add-click-event.png[align="center", width="1044"]

Add the logic of getting and saving user selected coordinates to the `map` click handler method:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/location/LocationDetailView.java[tags=view]
----
<1> To get `GeometryFactory` use `GeometryUtils` - the special utility class containing methods connected with JTS library.
<2> Convert the coordinates obtained from an `event` to the `Point` object using the `GeometryFactory` method.
<3> Use the `getEditedEntity()` method of the base `StandardDetailView` class to get the `Location` being edited.

Launch the application. Click on the `Locations` item in the `Application` menu. You will see the `Location.list` view. Click *Create*. The `Location.detail` view will open. Fill in the *City*, *Address* and *Type* fields. Click on the place in the map corresponding to the entered address. The *Building* field's value will be filled in automatically according to the coordinates of the point marked on the map. Save the location by clicking *OK*.

image::location-detail2.png[align="center", width="1134"]