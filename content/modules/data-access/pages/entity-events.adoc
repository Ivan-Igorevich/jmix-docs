= 实体事件

当使用 `DataManager` 读写数据时，Jmix 数据访问子系统会发送特定的 Spring 应用程序事件。可以创建事件监听器对保存和加载的实体实例做一些额外的操作。

[[entity-changed-event]]
== 使用 EntityChangedEvent

当实体保存至数据库时，框架会发送 `EntityChangedEvent` 事件。可以在保存事务内或者事务结束后处理该事件，无论哪种情况，此时数据库已经保存了变更后的数据。

`EntityChangedEvent` 包含变更操作的类型（创建、更新或删除）、变更实体的 id，还有变更属性的相关信息以及属性的旧值。对于引用属性，旧值包含引用实体的 id。

[[before-commit]]
=== 提交之前处理变更

如需在当前数据库事务中处理 `EntityChangedEvent`，创建一个带 `@EventListener` 注解的 bean 方法。框架会在实体保存至数据库但是事务尚未提交时调用该方法。在监听器方法中，可以对数据做任何修改，这些修改会与原始的修改一并提交。如果抛出任何异常，则回退所有操作。

下面的例子中，我们创建了 `Customer` 的一个关联实体，用来登记属性的改动。`Customer` 和 `CustomerGradeChange` 的变更会在同一个事务中提交：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/CustomerEventListener.java[tags=listener-bean;data-manager;before-commit]
----
<1> 确定变更类型。
<2> 确认属性修改。
<3> 获取变更实体的 id。
<4> 获取变更属性的旧值。
<5> 加载变更实体的新状态。

我们看看另一个例子。如果对 `Order` 实体的 `OrderLine` 进行新建、更新或删除，都会修改 `Order` 的 `amount` 属性：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/OrderLineEventListener.java[tags=entity-changed]
----
<1> 当 `OrderLine` 实体被删除时，我们无法加载该实例，所以只能用旧值加载关联的 `Order`。
<2> 用 `getOldReference()` 和 `getOldCollection()` 而非 `getOldValue()` 加载对一和对多的引用属性。

[[after-commit]]
=== 提交之后处理变更

如需在变更提交至数据库完成之后处理 `EntityChangedEvent`，创建一个带 `@TransactionalEventListener` 注解的 bean 方法。

注意，此时在“提交之后”事件处理器中的异常不会返回给调用端，也不会记录。因此，推荐在 try-catch 中调用代码。

如需在“提交之后”事件处理器中加载或保存任何数据，都需要新起一个事务。

下面的例子中展示了异常处理和使用 `DataManager` 在单独的事务中加载实体（参考 `joinTransaction(false)` 方法）：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/CustomerEventListener.java[tags=listener-bean;logger;data-manager;after-commit]
----

如需在“提交之后”事件处理器中保存实体，使用 `SaveContext` 及其 `setJoinTransaction(false)` 方法，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/CustomerEventListener.java[tags=save-after-commit]
----

如果需要多次调用 `DataManager` 或其他需要使用事务的 service，那么可以为整个方法启动一个新的事务，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/CustomerEventListener.java[tags=after-commit-tx]
----
<1> 使用 `Propagation.REQUIRES_NEW` 启动新事务。

[[saving-loading-events]]
== 使用 EntitySavingEvent 和 EntityLoadingEvent

框架在将要保存至数据库时，会发送 `EntitySavingEvent` 事件。与包含实体 id 的 <<entity-changed-event,EntityChangedEvent>> 不同，`EntitySavingEvent` 包含实体本身。可以在保存至数据库之前修改实体的信息。

如果是在数据库表新增实例时发出的事件，则事件的 `isNewEntity()` 方法返回 true。

可以用 `EntitySavingEvent` 监听器在实体保存至数据库之前初始化实体属性。示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/OrderEventListener.java[tags=saving-event]
----

当实体实例从数据库加载时，框架会发送 `EntityLoadingEvent` 事件。可以在该事件中，用实体的持久化属性初始化实体的非持久化属性。

下面的例子中，用 `EntitySavingEvent` 和 `EntityLoadingEvent` 维护一个加密属性：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/entity/Customer.java[tags=entity;encryption]
----

当实体保存实体时，敏感内容会被加密之后再存入数据库。而加载时，内容会先被解密然后设置到非持久化属性中以便用户访问：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/listener/CustomerEventListener.java[tags=listener-bean;encryption]
----
