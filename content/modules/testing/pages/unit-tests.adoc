= Юнит-тесты

Юнит-тест представляет собой наиболее узконаправленный вариант автоматизированного теста.

Термин "юнит-тест" используется для описания различных концепций, в том числе для обозначения автоматизированного тестирования в целом. Мы будем относиться к юнит-тесту как к автоматизированному тесту, проверяющему поведение определенного класса или набора классов без зависимостей (в первую очередь без контекста Spring и базы данных).

Jmix автоматически включает фреймворк тестирования https://junit.org/junit5/[JUnit 5^], а также https://site.mockito.org/[Mockito^] для поддержки создания фиктивных объектов (мокинга) зависимостей.

[[testing-isolated-functionality]]
== Тестирование изолированной функциональности

Для демонстрации процесса создания юнит-теста рассмотрим функциональность вычисления общей суммы для списка экземпляров `OrderLine`, связанных с `Order`.

Это вычисление выполняет отдельный класс под названием `OrderAmountCalculation`. Это не бин Spring, а обычный класс Java:

[source,java,indent=0]
----
include::example$/testing-ex1/src/main/java/com/company/demo/app/OrderAmountCalculation.java[tags=order-amount-calculation]
----

Пример юнит-теста для этой функциональности:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/OrderAmountCalculationTest.java[tags=unit-test-total-amount-calculation]
----
<1> Класс `OrderAmountCalculation` создается через конструктор без использования Spring.
<2> Сущности создаются путем вызова конструктора (без использования API Jmix `Metadata`).
<3> Проверка результата вычислений выполняется с использованием утверждений AssertJ.

Данный класс теста не содержит аннотаций тестов Spring Boot (например, `@SpringBootTest`), поэтому тест не использует контекст Spring и, следовательно, выполняется очень быстро. Однако отсутствие контекста Spring в тесте также означает, что невозможно использовать `@Autowired` в классе теста для получения экземпляров бинов Spring. Если у тестируемого класса есть зависимости от бинов Spring, эти зависимости должны быть созданы вручную.

[[mocking-with-mockito]]
== Создание фиктивных объектов с Mockito

В случае юнит-тестов указанное выше ограничение является приемлемым, поскольку обычно тестирование ограничивается изолированной функциональностью отдельного класса.

Рассмотрим следующий пример: есть класс, который вызывает API Jmix `TimeSource` для получения текущей даты. Он используется для подсчета количества бронирований, размещенных в текущем году для определенного клиента.

Вот реализация этого класса:

[source,java,indent=0]
----
include::example$/testing-ex1/src/main/java/com/company/demo/app/RecentOrdersCounter.java[tags=recent-order-counter]
----

Класс аннотирован как `@Component`, чтобы Spring автоматически создавал его и внедрял зависимости. Но если вы хотите протестировать эту функциональность в юнит-тесте, вам нужно вручную создать экземпляр класса `RecentOrdersCounter` и предоставить ему экземпляр `TimeSource` через конструктор.

Для тестирования функциональности `RecentOrdersCounter` имеет смысл проверить следующее:

> Предположим, у нас есть два заказа: один из 2019 года и один из 2020 года. Когда текущий год - 2020, мы ожидаем получить счетчик равным единице.

Для достижения этого необходимо управлять тем, что возвращает `TimeSource` как текущее время, в частности, эмулировать тот факт, что текущий год - 2020.

Такую эмуляцию можно реализовать с помощью Mockito - библиотеки для создания фиктивных объектов (моков). Она доступна в проектах Jmix по умолчанию.

Вот пример того, как может выглядеть тест:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/RecentOrdersCounterTest.java[tags=recent-order-counter-test]
----
<1> Метод `Mockito.mock()` создает фиктивный экземпляр, который можно использовать для управления поведением класса.
<2> Вызов `Mockito.when()` определяет, что при вызове метода `now()` на `TimeSource` он должен возвращать `2020-03-01` в виде `ZonedDateTime`.
<3> При создании экземпляра класса счетчика в конструктор передается мок (фиктивный экземпляр) `TimeSource`.

TIP: Если вы собираетесь тестировать ваши Spring-компоненты в юнит-тестах, используйте инжекцию зависимостей через конструктор вместо `@Autowired` на полях класса.

Более подробную информацию о использовании Mockito можно найти в его https://site.mockito.org/[документации^].

[[verify-behaviour-with-assertions]]
== Проверка поведения с использованием утверждений

Утверждения могут быть выражены с использованием библиотеки https://assertj.github.io/doc/[AssertJ^].

DSL AssertJ предоставляет fluent API для выполнения проверок результатов тестируемых классов. Методы утверждений (например, `assertThat`) должны быть статически импортированы из `org.assertj.core.api.Assertions`, например:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-import]
----

Вот простой пример утверждения AssertJ для строки:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-string-assertion]
----

Обратите внимание, что можно объединить несколько утверждений, принадлежащих одному объекту результата.

В случае неудачного теста JUnit / AssertJ предоставит правильное сообщение об ошибке с разницей между ожидаемым и фактическим поведением:

----
Expecting actual:
  "Mike Myers"
to end with:
  "Murphy"
----

В зависимости от типа объекта AssertJ предоставляет различные методы утверждений для сравнения значений. Например, при сравнении списков AssertJ предоставляет методы  `hasSize` и `contains`:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-list-assertion]
----

Дополнительную информацию о методах утверждений см. в https://assertj.github.io/doc/[документации AssertJ^].