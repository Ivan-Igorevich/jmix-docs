= DataGrid 数据网格
:page-aliases: backoffice-ui:vcl/components/data-grid.adoc

++++
<div class="jmix-ui-live-demo-container">
    <a href="https://demo.jmix.io/sampler/#main/sample?id=datagrid-basic-settings" class="live-demo-btn" target="_blank">在线示例</a>
</div>
++++

`DataGrid - 数据网格` 组件，与 xref:vcl/components/table.adoc[Table] 组件类似，适合用于展示、排序表格类数据，由于使用了在滚动时加载数据的延迟加载方式，所以此组件具有更好的数据行、列操作性能。

除此之外，`DataGrid` 还有以下功能：

* <<editing,行内编辑器>>；
* <<item-details-generator,数据详情生成器>>；
* Advanced configuration of <<headers-footers,Header 和 Footer>>；
* <<column-freezing,列锁定>>。

但是 `DataGrid` 没有数据分组的功能，而 `Table` 组件支持 xref:vcl/components/group-table.adoc[分组]。

组件的 XML 名称：`dataGrid`。

[[basics]]
== 基本用法

一个典型的 `dataGrid` 如下所示：

image::vcl/components/data-grid-anatomy.png[align="center"]

. 按钮面板
. 排序按钮
. 分页器
. 列控制按钮
. 数据行
. 表头行

以下为在 XML 文件中定义 `dataGrid` 的示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;collection-customers;data-end;layout-start;data-grid-simple;layout-end;]
----

其中，为 `Customer` 实体使用了 xref:data/collection-container.adoc[集合数据容器]。`DataGrid` 组件通过 `dataContainer` 属性与数据容器绑定，`columns` 元素定义那些实体属性要显示在数据网格的列中。

[[data-binding]]
== 数据绑定

[[declarative-binding]]
=== 声明式绑定

通常，使用 `dataContainer` 属性在界面 XML 描述中将数据与 `dataGrid` 绑定。此时需要使用一个 xref:data/collection-container.adoc[集合数据容器]。

[[using-key-value-containers]]
=== 使用键值对容器

数据网格还可以绑定至 xref:data/key-value-containers.adoc[键值对容器] 展示查询的纯数值和聚合值。示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;key-value-collection-sales;data-end;layout-start;key-value-grid;layout-end;]
----

[[meta-class]]
=== 编程式绑定

如需以编程的方式在界面控制器定义数据容器，则可以在 XML 中设置 xref:vcl/xml.adoc#meta-class[metaClass] 属性而非 xref:vcl/xml.adoc#data-container[dataContainer]。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=meta-class-data-grid]
----

界面控制器中，使用 `ContainerDataGridItems` 类将数据网格和数据容器绑定：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-customersDataGrid;inject-customersDc;init-start;programmatic-binding;init-end]
----

[[columns]]
== columns 元素

数据网格的列集合定义在 `columns` 元素中。如果未指定，则通过 `dataContainer` 定义的 xref:data-access:fetching.adoc#fetch-plan[fetch plan] 自动确定。

`columns` 元素有如下属性：

[[include-all]]
* `includeAll` 加载 `dataContainer` 中定义的 `fetchPlan` 的所有属性。
+
在下面的例子中，我们显示了 `customersDc` 中使用 fetch plan 的所有属性：
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=columns-include-all]
----
+
如果实体的 fetch plan 包含引用属性，该属性会按照其 xref:data-model:entities.adoc#instance-name[实例名] 进行展示。如果需要展示一个特定的级联属性，则需要在 fetch plan 和 `column` 元素中定义：
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=data-start;collection-customers-with-country;data-end;layout-start;columns-include-all-reference;layout-end]
----

[[exclude]]
* `exclude` 英文逗号分隔的属性列表，这些属性不会被加载到数据网格。
+
在下面的例子中，我们会显示除了 `id`、`maritalStatus` 和 `email` 之外的所有属性：
+
[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=columns-exclude]
----

[[column]]
=== column 元素

每一列是在内部的 `column` 元素中描述。

[[column-id]]

`id` - 非必需属性，指定列标识。如果没有设置，对应的 `property` 值会被用作该列的标识。如果 `id` 和 `property` 都不设置，会抛出 `GuiDevelopmentException` 异常。对于 <<data-grid-column-generation,代码生成列>>，则 `id` 属性是必需的。

[[column-property]]

`property` - 指定列对应的实体属性。可以是数据容器实体的属性，也可以是关联实体的属性，关联实体属性前面需要加上关联类名字并通过“.”连接。例如： 

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-column]
----

[TIP]
====
如需在 Jmix Studio 中添加 `column`，可以在界面 XML 或者 *Component Hierarchy* 面板中选择 `columns` 元素，然后点击 *Component Inspector* 面板的xref:studio:screen-designer.adoc#add-column[Add->Column] 按钮。
====

[[column-caption-options]]
=== 列标题

[[column-caption]]
`caption` - 可选属性，定义列标题。如果未设置，会使用实体属性的 xref:localization:message-bundles.adoc#localizing-data-model[本地化名称]。

隐藏列开关中也使用这个标题展示列名，除非在 <<collapsing-toggle-caption,collapsingToggleCaption>> 属性单独设置。

[[column-collapsing]]
=== 列折叠

[[column-collapsed]]
`collapsed` - 可选属性，设置为 `true` 时自动隐藏该列。`collapsed` 属性默认值为 `false`。用户可以通过数据网格右上角的 image:vcl/components/table-column-control-button.png[] 按钮提供的菜单控制列的可见性，此时需要设置 <<column-collapsing-allowed,columnsCollapsingAllowed>> 为 `true`。

[[column-collapsible]]
`collapsible` 定义用户是否可以通过 `DataGrid` 表格组件的列控制按钮隐藏/显示该列。默认为 `true`。

[[collapsing-toggle-caption]]

`collapsingToggleCaption` 设置在列控制按钮中该列的标题。默认为 `null`，此时列控制按钮中该列的标题与数据网格中该列的 <<column-caption,caption>> 一致。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-collapsed]
----

image::vcl/components/data-grid-collapse.gif[align="center"]

可以看到，`age` 列默认是折叠不显示的，但是用户可以通过 image:vcl/components/table-column-control-button.png[] 按钮的下拉菜单显示它。

另外，`firstName` 和 `lastName` 列是不能隐藏的。

列控制按钮的下拉项中，展示了 `hobby` 列的自定义标题。

列折叠可以通过事件 <<column-collapsing-change-event,ColumnCollapsingChangeEvent>> 进行跟踪。

[[column-width]]
=== 列宽度

`width` - 可选属性，定义列宽。只支持以像素为单位的数值类型。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-width]
----

image::vcl/components/data-grid-column-width.png[align="center"]

[[column-expand-ratio]]
`expandRatio` - 可选属性，设置列宽占比。比值必须大于等于 0。如果至少有一列设置了其他值，则忽略所有的隐式值，并且只使用设置的值。

默认情况下，所有列等宽（`expandRatio = 1`）。

如果同时设置了 `width` 和 `expandRatio` 属性，则 `expandRatio` 会被忽略。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-expandRatio-column]
----

image::vcl/components/data-grid-ratio.png[align="center"]

上面的例子中，`DataGrid` 组件有三列，列宽占比分别为 `0`、`1` 和 `2`。占比为 `0` 的列宽与内容所需的宽度一致。占比为 `1` 的列宽除了展示内容所需的宽度之外，还占用了剩余宽度的 1/3。占比为 `2` 的列宽除了展示内容所需的宽度之外，还占用了剩余宽度的 2/3。

如需清除占比值，可以为 `expandRatio` 属性设置一个负值。

[[column-minimum-width]]
`minimumWidth` 定义占比时列可占用的最小列宽，以像素为单位。

// 最小列宽的默认值通过 xref:app-properties.adoc#jmix.ui.data-grid.default-column-min-width[jmix.ui.data-grid.default-column-min-width] 属性设置。

[[column-maximum-width]]

`maximumWidth` 定义占比时列可占用的最大列宽，以像素为单位。

// 最大列宽的默认值通过 xref:app-properties.adoc#jmix.ui.data-grid.default-column-max-width[jmix.ui.data-grid.default-column-max-width] 属性设置。

[[column-resizable]]
=== 调整列宽

用户可以调整列宽：

image::vcl/components/data-grid-resize.gif[align="center"]

`resizable` 属性定义用户是否可以调整此列。默认所有列都可手动调整。

[[column-resize-mode]]
用 `columnResizeMode` 设置调整列宽时的动画效果。支持两种效果：

* `ANIMATED`，动画效果，列宽跟随鼠标拖拽（默认）。
* `SIMPLE`，简单效果，列宽会在拖拽动作结束后才发生改变。

列宽变化事件可以通过 <<column-resize-event,ColumnResizeEvent>> 跟踪。

[[reordering-allowed]]
=== 列重排

`DataGrid` 提供拖拽功能，用户可以改变数据网格内列的展示顺序。

// TODO: поменять тут скриншот. Этот от компонента Table. Жду решения тикета https://github.com/Haulmont/jmix-ui/issues/623

image::vcl/components/table-columns-reordering.gif[align="center"]

列重排的功能是默认开启的。如需禁用，可设置 `reorderingAllowed` 属性为 `false`。

列顺序改变可用 <<column-reorder-event,ColumnReorderEvent>> 跟踪。

[[column-freezing]]
=== 列锁定

`DataGrid` 支持将列固定在左侧。在查看有很多列的数据时，重要的列可以固定在左边总是可见。固定的列不会随着水平滚动条移动。

设置固定列的个数。`0` 表示不需要固定任何列，除了使用 <<checkbox-selection,复选框选择模式>> 开启多选时的预定义复选框列。设为 `-1` 的时候即使选择列也不固定。默认值为 `0`。

下面的示例是左侧固定两列的数据网格。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-frozen-column]
----

image::vcl/components/data-grid-frozen.gif[align="center"]

== 尺寸

=== 数据网格尺寸

除了 xref:vcl/xml.adoc#height[height] 和 xref:vcl/xml.adoc#width[width] 属性之外，`DataGrid` 还有 `minHeight` 和 `minWidth` 两个可选属性：

[[min-height]]
* `minHeight` 设置 `DataGrid` 组件的最小高度。

[[min-width]]
* `minWidth` 设置 `DataGrid` 组件的最小宽度。

=== 列尺寸

参阅 <<column-width,列宽度>> 章节的 `width`、`expandRatio`、`minimumWidth` 和 `maximumWidth` 属性。

=== 行尺寸

用 <<header-row-height,headerRowHeight>> 属性设置 header 高度。

[[body-row-height]]
用 `bodyRowHeight` 属性设置数据行高度（单位像素）。如果值为 `-1`，会在 `DataGrid` 显示前基于主题中空行的高度计算数据行的高度。

用 <<footer-row-height,footerRowHeight>> 属性设置 footer 高度。

下面示例中，`DataGrid` 组件有自定义的表头和数据行高度：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=sized-grid]
----

image::vcl/components/data-grid-custom-row-height.png[align="center"]

[[selection]]
== 选择

`DataGrid` 组件支持对数据行进行单选和多选。

[[selection-mode]]
`selectionMode` 属性设置行选择模式。有四种预定义的模式：

* `SINGLE` - 单选；
* `MULTI` - 多选；
* `MULTI_CHECK` - 复选框多选；
* `NONE` - 不可选择。

行选择事件可以用 <<selection-event,SelectionEvent>> 跟踪。

[[single-selection]]
=== 单选模式

`selectionMode` 属性设置为 `SINGLE` 时，用户一次只能选择单一的数据行。这是数据网格默认的选择模式。

[[multi-selection]]
=== 多选模式
`selectionMode` 属性设置为 `MULTI` 时，用户可以在数据网格中按下 *Ctrl* 或 *Shift* 建后，用键盘或鼠标选取多行。

[[checkbox-selection]]
=== 复选框选择模式
`selectionMode` 属性设置为 `MULTI_CHECK` 时，用户可以用最左列的复选框选择多行。

image::vcl/components/data-grid-checkbox-select.png[align="center"]

[[none-selection]]
=== 禁用选择
`selectionMode` 属性设置为 `NONE` 时，用户不能选择。

[[text-selection-enabled]]
=== 选择文本

`textSelectionEnabled` 属性定义是否可以在单元格中选取文本。默认值 `false`。

== 空状态

在数据容器没有数据或者没有设置数据容器时，支持为 `DataGrid` 设置展示空状态消息或链接。

[[empty-state-message]]
空状态消息通过 `emptyStateMessage` 属性定义。可以用于显示无数据的原因。

[[empty-state-link-message]]
空状态链接通过 `emptyStateLinkMessage` 属性定义。可以显示加载数据需要进行的操作。

示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=placeholder-grid]
----

image::vcl/components/data-grid-placeholder.png[align="center"]

`emptyStateMessage` 和 `emptyStateLinkMessage` 属性都可以从 xref:localization:message-bundles.adoc#using-messages-in-ui[消息包] 中加载本地化消息。

用 <<empty-state-link-click-handler,EmptyStateLinkClickHandler>> 处理空状态链接的点击。

[[column-collapsing-allowed]]
== 列可见控制

用户可以用数据网格 header 右侧的 image:vcl/components/table-column-control-button.png[] 列控制按钮选择 <<column-collapsing,折叠>> 隐藏哪些列。

当前展示列在下拉列表中是勾选状态。其他的菜单项：

* `Select all` - 展示所有的数据网格列。
* `Deselect all` - 隐藏所有能隐藏的列。

image::vcl/components/data-grid-column-collapsing-allowed.png[align="center"]

如果 `columnsCollapsingAllowed` 属性设置为 `false`，则用户不能折叠列。默认值是 `true`。

[[headers-footers]]
== Headers 和 Footers

[[header-visible]]
`headerVisible` 属性定义是否显示 `DataGrid` header。默认值是 `true`。

[[header-row-height]]
使用 `headerRowHeight` 属性设置 header 的行高（单位是像素）。如果值设置为 `-1`，则在 `DataGrid` 展示之前根据主题中空行的高度计算行高。默认值是 `-1`。

[[footer-visible]]
`footerVisible` 属性定义是否显示 `DataGrid` footer。默认值是 `true`。

[[footer-row-height]]
使用 `footerRowHeight` 属性设置 footer 的行高（单位是像素）。如果值设置为 `-1`，则在 `DataGrid` 展示之前根据主题中空行的高度计算行高。默认值是 `-1`。

`HeaderRow` 和 `FooterRow` 接口分别用来展示 header 和 footer 单元格。这些单元格可以是合并列。

`DataGrid` 的下列方法支持创建和管理 `DataGrid` 的 header 和 footer：

* `appendHeaderRow()`、`appendFooterRow()` - 在 header/footer 底部添加新行。
* `prependHeaderRow()`、`prependFooterRow()` - 在 header/footer 顶部添加新行。
* `addHeaderRowAt()`、`addFooterRowAt()` - 在 header/footer 中的指定位置添加新行。当前行和后面已经存在的行依次下移且索引值相应增加。
* `removeHeaderRow()`、`removeFooterRow()` - 从 header/footer 删除指定的行。
* `getHeaderRowCount()`、`getFooterRowCount()` - 获取 header/footer 的行数。
* `setDefaultHeaderRow()` - 设置 header 的默认行。默认行是一个特殊的 header，提供列排序的功能。

`HeaderCell` 和 `FooterCell` 接口提供自定义静态单元格功能：

* `setStyleName()` - 为单元格设置自定义样式名称。
* `getCellType()` - 返回单元格内容类型。静态单元格枚举类型 `DataGridStaticCellType` 有三个值：

** `TEXT`
** `HTML`
** `COMPONENT`

* `getComponent()`、`getHtml()`、`getText()` - 不同类型单元格获取内容的方法。

下面这个例子中，header 包含合并的单元格，footer 显示经计算得出的值。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-header-footer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=init-footer-header-var;init-start;init-footer-header;init-end;init-footer;init-header;get-average;calculate-member-count]
----

image::vcl/components/data-grid-header-footer.png[align="center"]

[[aggregatable]]
== 聚合

`DataGrid` 支持对行内值进行聚合运算。

支持下列运算符：

* `SUM` - 求和
* `AVG` - 求平均值
* `COUNT` - 计数
* `MIN` - 最小值
* `MAX` - 最大值

如需启用对 `DataGrid` 的行进行聚合运算，按照下列配置：

. 设置 `aggregatable` 属性值为 `true`。
. 为聚合列设置 `aggregation` 元素。
+

[[aggregation-type]]
. 设置 `aggregation` 元素的 `type` 属性，表示聚合的函数。

[TIP]
====
如需在 Jmix Studio 中定义 `aggregation`，可以在界面 XML 或者 *Component Hierarchy* 面板中选择聚合单元格的列，然后点击 *Component Inspector* 面板的 xref:studio:screen-designer.adoc#component-inspector-add-button[Add]*->Aggregation* 按钮。
====

聚合值展示在附加行中。

[[aggregation-position]]
`aggregationPosition` 属性可以设置聚合值行的位置：`TOP` 或 `BOTTOM`。默认为 `TOP`。

[NOTE]
====
默认情况下，聚合列只支持数字类型，比如 `Integer`、`Double`、`Long` 和 `BigDecimal`。
====

带聚合列的 `DataGrid` XML 描述示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=aggregation-grid]
----

image::vcl/components/data-grid-aggregation.png[align="center"]

[[aggregation-value-description]]
`valueDescription` 属性定义一个提示，当用户的光标悬停在聚合值上时通过弹出框展示这个提示。对于上面列出的运算（`SUM`、`AVG`、`COUNT`、`MIN`、`MAX`），提示弹窗已经默认开启。

[[aggregation-formatter]]
可以指定不同于 `Datatype` 标准格式的 xref:vcl/miscellaneous/formatter.adoc[formatter] 显示聚合值：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-aggregation-format]
----

[[aggregation-strategy-class]]
`aggregation` 元素还可以包含 `strategyClass` 属性，指定一个实现 `AggregationStrategy` 接口的类。

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/CustomerHobbyAggregation.java[tags=aggregation-strategy]
----

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-aggregation-strategy]
----

[[grid-sorting]]
== 排序

`DataGrid` 支持对列数据进行排序。排序功能默认开启。

`sortable` 属性可以启用数据网格的排序功能。默认为 `true`。开启后，点击列名会在列名右边显示 image:vcl/components/table-sortable-down.png[]/image:vcl/components/table-sortable-up.png[] 图标。

按住 `Shift` 的同时选择多列可以按多列排序。

[[column-sortable]]
使用特定 <<column,列>> 的 `sortable` 属性可以禁用该列的排序功能。

下面的例子中，我们禁用了 `lastName` 列的排序：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-sorting]
----

[[column-sort]]

`column` 元素的 `sort` 属性可以设置该列的初始排序。值选项：

* `ASCENDING` - 顺序（0 -> 9 -> A -> Z）。
* `DESCENDING` - 倒序（Z -> A -> 9 -> 0）。

示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-sort]
----

[CAUTION]
====
`DataGrid` 一次只能按照一列进行排序。如果有多列设置了 `sort` 属性或者同时设置了 `sort` 和 `sortable="false"`，界面会报错。
====

`DataGrid` 排序事件可以用 <<sort-event,SortEvent>> 跟踪。

[[paging]]
== 分页

`dataGrid` 可以使用 xref:vcl/components/simple-pagination.adoc[] 组件来提供分页功能：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-paging]
----

image::vcl/components/data-grid-pagination.png[align="center"]

或者，可以使用独立的 xref:vcl/components/pagination.adoc[] 组件。

[[actions]]
== DataGrid 操作

`DataGrid` 组件实现了 `ActionsHolder` 接口，可以包含自定义操作和 xref:actions/standard-actions.adoc#list-actions[标准列表操作]。

数据网格的操作定义在内部的 `actions` 元素中。

[TIP]
====
如需在 Jmix Studio 中添加 `action`，可以在界面 XML 或者 *Component Hierarchy* 面板中选择组件，然后点击 *Component Inspector* 面板的 xref:studio:screen-designer.adoc#add-action[Add]*->Action* 按钮。
====

如果操作有标题，则会显示在数据网格的 <<context-menu-enabled,右键菜单>> 中。此外，数据网格的操作可以分配给界面中任意位置的按钮。

[[buttons-panel]]
可以用 xref:vcl/containers/buttons-panel.adoc[ButtonsPanel] 容器在数据网格上方显示操作按钮。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-actions-buttons-panel]
----
<1> 定义 `create` 标准操作。
<2> 定义 `about` 自定义操作。
<3> 在数据网格内定义 `ButtonsPanel` 容器。

image::vcl/components/data-grid-actions.png[align="center"]

[[data-grid-column-generation]]
== 列生成

通过 `ColumnGeneratorEvent` 事件的处理器可以添加动态生成或者动态计算的列，并提供自定义的数据展示。

在渲染数据网格时，事件处理器由框架对每个单元格进行调用。`ColumnGeneratorEvent` 包含当前行展示的实体信息以及列标识符。

可以用 Studio 创建 `ColumnGeneratorEvent` 事件的处理器。需选择 Studio 建议的生成类型和对应的 <<renderers,渲染器>> 类型。

示例，我们生成一个包含 customer 全名称的列。

首先，创建一个 id 为 `fullName` 的列：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=text-renderer]
----

然后用 Studio 为 `fullName` 列创建 `ColumnGeneratorEvent` 处理器并实现如下：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-generator]
----

结果：

image::vcl/components/data-grid-generated-column.png[align="center"]

`fullName` 列是一个使用 <<text-renderer,TextRenderer>> 的生成列。

如需编程式注册列生成处理器，使用 `DataGrid` 组件的 `addGeneratedColumn()` 方法。

[[exporting-column-values]]
== 列值导出

使用 xref:grid-export:index.adoc[表格导出] 扩展组件可以将 `DataGrid` 组件的内容导出成支持的文件类型。

安装完组件后，可以为数据网格定义 xref:grid-export:actions.adoc#excel-export-action[excelExport] 或 xref:grid-export:actions.adoc#json-export-action[jsonExport] 操作，也可使用 xref:grid-export:exporters.adoc[表格导出器]。

下面的例子中，在使用 `excelExport` 操作导出 XLSX 文件时，为数据的某一列设置了自定义的输出。

界面描述：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-export-start;grid-export-end]
----

界面控制器：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-grid-excel-export;init-start;add-column-value-provider;init-end]
----

<1> 该方法一个参数是列标识符，第二个是从列中获取展示值的函数。

[[renderers]]
== 渲染器

数据在列中的显示方式可以使用带参数的渲染器（renderer）以声明式的方法自定义。一些 `DataGrid` 的渲染器通过特定的 XML 元素设置，并且定义了对应的属性作为参数。对常规列和生成列，都可以声明渲染器。

框架提供下列渲染器：

* <<button-renderer,ButtonRenderer>>
* <<image-renderer,ImageRenderer>>
* <<check-box-renderer,CheckBoxRenderer>>
* <<number-renderer,NumberRenderer>>
* <<local-date-time-renderer,LocalDateTimeRenderer>>
* <<local-date-renderer,LocalDateRenderer>>
* <<date-renderer,DateRenderer>>
* <<progress-bar-renderer,ProgressBarRenderer>>
* <<html-renderer,HtmlRenderer>>
* <<clickable-text-renderer,ClickableTextRenderer>>
* <<text-renderer,TextRenderer>>
* <<component-renderer,ComponentRenderer>>
* <<icon-renderer,IconRenderer>>

[[button-renderer]]
=== ButtonRenderer

`ButtonRenderer` 渲染为按钮，按钮标题为字符串。

`ButtonRenderer` 不能在 XML 描述中定义，因为没有办法在 XML 描述中定义渲染器点击监听器。Studio 会在界面控制器的 `onInit()` 中生成 `ButtonRenderer` 的声明代码，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-gridButtonRenderer;inject-notifications;init-start;button-renderer;init-end]
----

image::vcl/components/data-grid-button-renderer.png[align="center"]

[[image-renderer]]
=== ImageRenderer

* `ImageRenderer` 是一个展示图片的渲染器。对应属性的值用作图片地址，地址可以是主题资源或 URL。

`ImageRenderer` 不能在 XML 描述中定义，因为没有办法在 XML 描述中定义渲染器点击监听器。Studio 会在界面控制器的 `onInit()` 中生成 `ImageRenderer` 的声明代码，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-imageGrid;inject-notifications;init-start;image-renderer;init-end]
----

结果：

image::vcl/components/data-grid-image-renderer.png[align="center"]

[[check-box-renderer]]
=== CheckBoxRenderer

`CheckBoxRenderer` 将布尔值作为复选框展示。

`DataGrid` 的 `column` 元素有一个子元素 `checkBoxRenderer`：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-check-box-renderer]
----

[[number-renderer]]
=== NumberRenderer

`NumberRenderer` 按照定义的格式展示数字。

`DataGrid` 的 `column` 元素有一个子元素 `numberRenderer`，`numberRenderer` 有可选属性 `nullRepresentation` 和必需字符串属性 `format`。

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-number-renderer]
----

`formatString` 是描述数字格式的字符串，用来创建 `NumberFormat` 实例。

[[local-date-time-renderer]]
=== LocalDateTimeRenderer

`LocalDateTimeRenderer` 以 `LocalDateTime` 值展示日期时间。

`DataGrid` 的 `column` 元素有子元素 `localDateTimeRenderer`，该元素有非必要的 `nullRepresentation` 属性和必填的 `format` 字符串属性：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-local-date-time-renderer]
----

[[local-date-renderer]]
=== LocalDateRenderer

`LocalDateRenderer` 以 `LocalDate` 值显示日期。

`DataGrid` 的 `column` 元素有子元素 `localDateRenderer`，该元素有非必要的 `nullRepresentation` 属性和必填的 `format` 字符串属性：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-local-date-renderer]
----

结果：

image::vcl/components/data-grid-local-date-renderer.png[align="center"]

[[date-renderer]]
=== DateRenderer

`DateRenderer` 用定义的格式显示日期。

`DataGrid` 的 `column` 元素有子元素 `dateRenderer`，该元素有非必要的 `nullRepresentation` 属性和必填的 `format` 字符串属性：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-date-renderer]
----

`formatString` 是描述日期时间格式的字符串，用来创建 `DateFormat` 实例。

image::vcl/components/data-grid-date-renderer.png[align="center"]

注意这里 `startDate` 字段有 `DateRenderer`，而 `endDate` 没有。

[[progress-bar-renderer]]
=== ProgressBarRenderer

`ProgressBarRenderer` 将 0~1 之间 `double` 类型的值展示为 `ProgressBar` 组件。

`DataGrid` 的 `column` 元素有子元素 `progressBarRenderer`：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-progress-bar-renderer]
----

结果：

image::vcl/components/data-grid-progress-bar-renderer.png[align="center"]

[[html-renderer]]
=== HtmlRenderer

`HtmlRenderer` 展示 HTML。

`DataGrid` 的 `column` 元素有子元素 `htmlRenderer`，该元素有非必要的属性 `nullRepresentation`。

下面是渲染 `endDate` 属性的示例：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-html-renderer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=html-renderer]
----

结果：

image::vcl/components/data-grid-html-renderer.png[align="center"]

[[clickable-text-renderer]]
=== ClickableTextRenderer

`ClickableTextRenderer` 将普通的文本字符串显示为链接，并有点击事件处理器。

`ClickableTextRenderer` 不能在 XML 描述中定义，因为没有办法在 XML 描述中定义渲染器点击监听器。Studio 会在界面控制器的 `onInit()` 中生成 `ClickableTextRenderer` 的声明代码，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-gridClick;inject-notifications;init-start;clickable-text-renderer;init-end]
----

结果：

image::vcl/components/data-grid-click-text-renderer.gif[align="center"]

[[text-renderer]]
=== TextRenderer

`TextRenderer` 展示简单的字符串。

`DataGrid` 的 `column` 元素有子元素 `textRenderer`，该元素有非必要的 `nullRepresentation` 属性：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=text-renderer]
----

[[component-renderer]]
=== ComponentRenderer

`ComponentRenderer` UI 组件渲染器。

`DataGrid` 的 `column` 元素有子元素 `componentRenderer`：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-component-renderer]
----

下面的例子中，我们用 `Slider` 组件展示 `age` 的值。

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=component-renderer]
----

结果：

image::vcl/components/data-grid-component-renderer.png[align="center"]

[[icon-renderer]]
=== IconRenderer

`IconRenderer` 展示 `JmixIcon` 的渲染器。

`DataGrid` 的 `column` 元素有子元素 `iconRenderer`。

下面示例，渲染生成的 `hasEmail` 属性：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-icon-renderer]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=icon-renderer]
----

结果：

image::vcl/components/data-grid-icon-renderer.png[align="center"]

[[item-details-generator]]
== 数据详情生成器

数据详情是在可展开的区域展示特定行的更多信息。

`DetailsGenerator` 接口支持创建自定义组件展示数据详情。

用 Studio 可以为 `DataGrid` 创建 DetailsGenerator` 处理器（参阅 <<handlers,处理器>>）并实现：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-detailsGrid;details-generator;create-close-button;get-content]
----

如需手动处理显示和隐藏，需要自己实现监听器。下面的例子中，我们在 `DataGrid` 组件的 `ItemClickAction` 中打开详情：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=item-click-event]
----

结果：

image::vcl/components/data-grid-detail-generator.png[align="center"]

[[editing]]
== 编辑

[[editor-enabled]]
`DataGrid` 组件支持行内编辑器来编辑单元格数据。设置 `editorEnabled` 属性为 `true` 启用行内编辑。

=== 使用方法

* 双击需要编辑的字段或选中可编辑单元格后按下回车都可以开启行内编辑。

[[column-editable]]
* 带有 `editable = true` 属性的列展示实体属性编辑的组件。不可编辑字段则无法使用。
* 每个可编辑列的编辑组件是根据对应实体的属性自动选取的。例如，对于字符串和数字类型的属性，使用 xref:vcl/components/text-field.adoc[TextField]，日期时间 - xref:vcl/components/date-field.adoc[DateField]，枚举 - xref:vcl/components/combo-box.adoc[ComboBox]，实体引用 - xref:vcl/components/entity-picker.adoc[EntityPicker]。
* 当一行处于编辑模式时，会显示默认的 *OK* 和 *Cancel* 按钮，用户可提交或取消编辑。
* 如需保存修改并退出编辑模式，点击 *OK* 按钮或按回车。
* 如需放弃修改并退出编辑模式，点击 *Cancel* 按钮或按 *Esc*。

image::vcl/components/data-grid-editing.png[align="center"]

[[editor-buffered]]
=== 模式

编辑模式分为缓存模式和非缓存模式。

* 缓存模式编辑，数据的修改必须显式提交。
* 非缓存模式编辑，当字段失去焦点时自动提交。

`editorBuffered` 属性用于设置缓存编辑模式。默认为 `true`。

此时，数据的修改只是提交至数据容器。数据保存至数据库的过程通常在界面提交时由 xref:data/data-context.adoc[] 完成。

=== 自定义行内编辑器

[[editor-cancel-caption]]
`editorCancelCaption` 属性设置 `DataGrid` 组件编辑器中取消（cancel）按钮的标题。

[[editor-save-caption]]
`editorSaveCaption` 属性设置 `DataGrid` 组件编辑器中保存（save）按钮的标题。

[[edit-field-generator]]
可以通过 `EditorFieldGenerationContext` 类对编辑器组件进行定制。

在 `DataGrid` 编辑模式中创建一个编辑字段生成器，用于为该列生成编辑组件，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=inject-citiesDc;edit-field-generator]
----

结果：

image::vcl/components/data-grid-edit-field-generator.png[align="center"]

还有通过声明式的方式定义使用何种组件选择实体的通用机制。基于 xref:app-properties.adoc#jmix.ui.component.entity-field-type[jmix.ui.component.entity-field-type] 和 xref:app-properties.adoc#jmix.ui.component.entity-field-actions[jmix.ui.component.entity-field-actions] 属性。

例如，可以在 `application.properties` 文件中增加下面的内容：

[source,properties]
----
jmix.ui.component.entity-field-type.uiex1_City = entityComboBox
jmix.ui.component.entity-field-actions.uiex1_City = entity_lookup, entity_open, entity_clear
----

然后，会自动为 `City` 实体生成 `EntityComboBox` 组件：

image::vcl/components/data-grid-editable-custom-field.png[align="center"]

[[editor-cross-field-validate]]
=== 跨字段验证

`DataGrid` 的行内编辑器也可以考虑实体约束（跨字段验证）。如果有验证错误，`DataGrid` 会展示错误消息。用 `editorCrossFieldValidate` 属性启用/禁用验证。默认值为 `true`。

=== 编辑器事件

编辑器事件提供对其使用组件的访问，支持修改或使用组件值。

[[editor-open-event]]
* `EditorOpenEvent` 在 `DataGrid` 编辑器打开之前发送的事件。
+
示例：
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=editor-open-event]
----

[[editor-close-event]]
* `EditorCloseEvent` 在 `DataGrid` 编辑器关闭之后发送的事件。

[[editor-pre-commit-event]]
* `EditorPreCommitEvent` 在数据更新之前发送的事件。

[[editor-post-commit-event]]
* `EditorPostCommitEvent` 在数据更新之后发送的事件。

=== 行内编辑器方法

[[method-get-edited-item]]
* `getEditedItem()` 返回正在被编辑的数据项，或 `null`，如果此时无数据正在编辑。

[[method-is-editor-active]]
* `isEditorActive()` 是否正在编辑某个数据项。

[[method-edit]]
* `edit()` 方法为指定实体打开编辑接口。如果数据项在当前界面区域不可见，`DataGrid` 会将数据项滚动到可视区域。

[[context-menu-enabled]]
== 右键菜单

在数据网格中点击右键可以激活右键菜单。

`contextMenuEnabled` 属性可以开启右键菜单。默认值为 `true`。右键菜单展示 <<actions,数据网格操作>>（如果有的话）。

右键点击的事件可以通过 <<context-click-event,ContextClickEvent>> 跟踪。

[[stylename]]
== 样式

可以在界面 XML 或者控制器中使用 `stylename` 属性为 `DataGrid` 组件设置预定义样式：

[source, xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/datagrid/data-grid-screen.xml[tags=grid-stylename]
----

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=set-style-name]
----

预定义样式：

* `borderless` - 删除数据网格外边框；
* `no-horizontal-lines` - 删除行之间的水平分隔线；
* `no-vertical-lines` - 删除列之间的垂直分隔线；
* `no-stripes` - 删除行间隔背景色。

`DataGrid` 的外观可以使用带 `$jmix-datagrid-*` 前缀的 SCSS 变量进行自定义。在创建了 xref:themes/custom_theme.adoc[自定义主题] 之后，可以在可视化编辑器中修改这些变量。

也可以参阅 <<row-style-provider>>。

[[methods]]
== DataGrid 接口方法

[[methods-get-columns]]
* `getColumns()` 按当前界面的展示顺序获取列集合。

[[methods-get-visible-columns]]
* `getVisibleColumns()` 获取有权限查看的所有列集合。

[[methods-sort]]
* `sort()` 方法对 `DataGrid` 的数据按照所选择的列和排序规则进行 <<grid-sorting,排序>>。

[[methods-scroll-to]]
* `scrollTo()` 将 `DataGrid` 滚动到指定行。需要一个实体实例作为输入参数来指定滚动到哪一行。除了实体实例参数，另有重载方法支持 `ScrollDestination` 参数，该参数可以为以下值：

** `ANY` - 滚动尽量少的位置来展示所目标元素。如果元素在视图内，则根据当前滚动条的位置，此配置与 `START` 或 `END` 相同。如果元素不在视图内，则与 `START` 相同。
** `START` - 使所需要的数据展示在可见部分的顶端。当前视图不会滚动超过所见内容的距离。
** `MIDDLE` - 使所需要的数据展示在可见部分的中部。当前视图不会滚动超过所见内容的距离，即使数据比当前视图能展示的范围还要大。且视图不会滚动超过第一个元素。
** `END` - 使所需要的数据展示在可见部分的底部。视图不会滚动超过第一个元素。

[[methods-scroll-to-start-end]]
* `scrollToStart()` 和 `scrollToEnd()` - 分别滚动 `DataGrid` 至第一个和最后一个数据项。

[[methods-get-aggregation-results]]
* The `getAggregationResults()` 方法返回 <<aggregatable,聚合>> 结果的 map，key 为 `DataGrid` 的列标识符，value 为聚合值。

[[handlers]]
== 事件和处理器

include::../events-hanlers-generation-tip.adoc[]

[[column-collapsing-change-event]]
=== ColumnCollapsingChangeEvent

`ColumnCollapsingChangeEvent` 当列的 <<column-collapsing,折叠>> 状态发生改变时发送。

下面示例为 XML 中 id 是 `collapseGrid` 的数据网格订阅了该事件：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-collapsing-change-event]
----

如需以编程的方式注册事件处理器，使用组件的 `addColumnCollapsingChangeListener()` 方法。

[[column-reorder-event]]
=== ColumnReorderEvent

参阅 xref:vcl/components/table.adoc#column-reorder-event[ColumnReorderEvent]。

[[column-resize-event]]
=== ColumnResizeEvent

`ColumnResizeEvent` 当列发生 <<column-resizable,大小改变>> 时发送。

下面示例为 XML 中 id 是 `resizedEventGrid` 的数据网格订阅了该事件：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=column-resize-event]
----

如需以编程的方式注册事件处理器，使用组件的 `addColumnResizeListener()` 方法。

[[context-click-event]]
=== ContextClickEvent

`ContextClickEvent` 当在 `DataGrid` 内点击鼠标右键时发送。

`ContextClickEvent` 包含鼠标事件的详细信息。

下面示例为 XML 中 id 是 `contextGrid` 的数据网格订阅了该事件：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=context-click-event]
----

如需以编程的方式注册事件处理器，使用组件的 `addContextClickListener()` 方法。

=== EditorCloseEvent

参阅 <<editor-close-event,EditorCloseEvent>>。

=== EditorOpenEvent

参阅 <<editor-open-event,EditorOpenEvent>>。

=== EditorPostCommitEvent

参阅 <<editor-post-commit-event,EditorPostCommitEvent>>。

=== EditorPreCommitEvent

参阅 <<editor-pre-commit-event,EditorPreCommitEvent>>。

[[item-click-event]]
=== ItemClickEvent

`ItemClickEvent` 当用户点击数据网格时发送。`ItemClickEvent` 包含下列信息：

* 鼠标事件详情；
* 点击行的实体实例；
* 数据项的 `id`；
* 点击列的 `id`。

下面的示例，当用户单击可编辑单元格时，让用户开始 <<editing,编辑>>：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=item-click-event2]
----

如需以编程的方式注册事件处理器，使用组件的 `addItemClickListener()` 方法。

[[selection-event]]
=== SelectionEvent

参阅 xref:vcl/components/table.adoc#selection-event[SelectionEvent]。

[[sort-event]]
=== SortEvent

`SortEvent` 当数据发生 <<grid-sorting,排序>> 变化时发送。

下面示例为 XML 中 id 是 `sortGrid` 的数据网格订阅了该事件：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=sort-event]
----

如需以编程的方式注册事件处理器，使用组件的 `addSortListener()` 方法。

[[context-help-icon-click-handler]]
=== ContextHelpIconClickHandler

参阅 xref:vcl/api.adoc#context-help-icon-click-handler[ContextHelpIconClickHandler]。

[[details-generator]]
=== DetailsGenerator

参阅 <<item-details-generator,DetailsGenerator>>。

[[empty-state-link-click-handler]]
=== EmptyStateLinkClickHandler

参阅 xref:vcl/components/table.adoc#empty-state-click-event[EmptyStateLinkClickHandler]。

[[lookup-select-handler]]
=== LookupSelectHandler

参阅 xref:vcl/components/table.adoc#lookup-select-handler[LookupSelectHandler]。

[[row-description-provider]]
=== RowDescriptionProvider

`RowDescriptionProvider` 当用户鼠标悬停在 `DataGrid` 某行时，展示行的描述信息（提示框）。如果为某列也设置了 `DescriptionProvider`，那么，由 `RowDescriptionProvider` 生成的行描述信息只为那些单元格描述 provider 返回 `null` 的单元格展示。

下面的示例中，我们展示 `rowDescGrid` 的 `RowDescriptionProvider` 用法：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=row-description-provider]
----

结果：

image::vcl/components/data-grid-row-description.gif[align="center"]

如需以编程的方式注册 provider，使用组件的 `setRowDescriptionProvider()` 方法。

[[row-style-provider]]
=== RowStyleProvider

`RowStyleProvider` 支持 `DataGrid` 行级的样式 provider。
`DataGrid` 可以使用多个 providers 获取行的样式名。

设置样式示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/component/datagrid/DataGridScreen.java[tags=row-style-provider]
----

然后需要在应用程序主题中定义行样式。创建主题的详细信息请参阅 xref:themes.adoc[主题]。CSS 选择器中需要使用界面控制器中 provider 返回的样式名。示例：

[source,css,indent=0]
----
include::example$/ex1/src/main/themes/helium-extended/helium-extended.scss[tags=grid-rows-style]
----

结果：

image::vcl/components/data-grid-row-style.png[align="center"]

[[xml]]
== XML 属性

include::../xml-studio-tip.adoc[]

=== DataGrid XML 属性

<<aggregatable,aggregatable>> -
<<aggregation-position,aggregationPosition>> -
xref:vcl/xml.adoc#align[align] -
<<body-row-height,bodyRowHeight>> -
xref:vcl/xml.adoc#box-expand-ratio[box.expandRatio] -
xref:vcl/xml.adoc#caption[caption] -
xref:vcl/xml.adoc#caption-as-html[captionAsHtml] -
xref:vcl/xml.adoc#colspan[colspan] -
<<column-resize-mode,columnResizeMode>> -
<<column-collapsing-allowed,columnCollapsingAllowed>> -
xref:vcl/xml.adoc#context-help-text[contextHelpText] -
xref:vcl/xml.adoc#context-help-text-html-enabled[contextHelpTextHtmlEnabled] -
<<context-menu-enabled,contextMenuEnabled>> -
xref:vcl/xml.adoc#css[css] -
xref:vcl/xml.adoc#data-container[dataContainer] -
xref:vcl/xml.adoc#description[description] -
xref:vcl/xml.adoc#description-as-html[descriptionAsHtml] -
<<editor-buffered,editorBuffered>> -
<<editor-cancel-caption,editorCancelCaption>> -
<<editor-cross-field-validate,editorCrossFieldValidate>> -
<<editor-enabled,editorEnabled>> -
<<editor-save-caption,editorSaveCaption>> -
<<empty-state-link-message,emptyStateLinkMessage>> -
<<empty-state-message,emptyStateMessage>> -
xref:vcl/xml.adoc#enable[enable] -
<<footer-row-height,footerRowHeight>> -
<<footer-visible,footerVisible>> -
<<column-freezing,frozenColumnCount>> -
<<header-row-height,headerRowHeight>> -
<<header-visible,headerVisible>> -
xref:vcl/xml.adoc#height[height] -
xref:vcl/xml.adoc#html-sanitizer-enabled[htmlSanitizerEnabled] -
xref:vcl/xml.adoc#icon[icon] -
xref:vcl/xml.adoc#id[id] -
<<meta-class,metaClass>> -
<<min-height,minHeight>> -
<<min-width,minWidth>> -
<<reordering-allowed,reorderingAllowed>> -
xref:vcl/xml.adoc#responsive[responsive] -
xref:vcl/xml.adoc#rowspan[rowspan] -
<<selection-mode,selectionMode>> -
<<grid-sorting,sortable>> -
<<stylename,stylename>> -
xref:vcl/xml.adoc#tab-index[tabIndex] -
<<text-selection-enabled,textSelectionEnabled>> -
xref:vcl/xml.adoc#visible[visible] -
xref:vcl/xml.adoc#width[width]

[[xml-data-grid-elements]]
=== DataGrid XML 元素

<<actions,actions>> -
<<buttons-panel,buttonsPanel>> -
<<columns,columns>> -
<<paging,simplePagination>>

=== Columns XML 属性

<<exclude,exclude>> -
<<include-all,include-all>>

=== Column XML 属性

xref:vcl/xml.adoc#box-expand-ratio[box.expandRatio] -
<<column-caption,caption>> -
<<column-collapsed,collapsed>> -
<<column-collapsible,collapsible>> -
<<collapsing-toggle-caption,collapsingToggleCaption>> -
xref:vcl/xml.adoc#colspan[colspan] -
<<column-editable,editable>> -
<<column-expand-ratio,expandRatio>> -
<<column-id,id>> -
<<column-maximum-width,maximumWidth>> -
<<column-minimum-width,minimumWidth>> -
<<column-property,property>> -
<<column-resizable,resizable>> -
xref:vcl/xml.adoc#rowspan[rowspan] -
<<column-sort,sort>> -
<<column-sortable,sortable>> -
<<column-width,width>>

=== Column XML 元素

<<aggregatable,aggregation>> -
<<check-box-renderer,checkBoxRenderer>> -
<<component-renderer,componentRenderer>> -
<<date-renderer,dateRenderer>> -
<<html-renderer,htmlRenderer>> -
<<icon-renderer,iconRenderer>> -
<<local-date-renderer,localDateRenderer>> -
<<local-date-time-renderer,localDateTimeRenderer>> -
<<number-renderer,numberRenderer>> -
<<progress-bar-renderer,progressBarRenderer>> -
<<text-renderer,textRenderer>>

=== Aggregation XML 属性

<<aggregation-strategy-class,strategyClass>> -
<<aggregation-type,type>> -
<<aggregation-value-description,valueDescription>>

=== Aggregation XML 元素

<<aggregation-formatter,formatter>>

== API

<<method-edit,edit>> -
<<methods-get-aggregation-results,getAggregationResults>> -
<<methods-get-columns,getColumns>> -
<<method-get-edited-item,getEditedItem>> -
<<methods-get-visible-columns,getVisibleColumns>> -
<<method-is-editor-active,isEditorActive>> -
<<methods-scroll-to,scrollTo>> -
<<methods-scroll-to-start-end,scrollToEnd>> -
<<methods-scroll-to-start-end,scrollToStart>> -
xref:vcl/components/table.adoc#methods-set-enter-press-action[setEnterPressAction] -
xref:vcl/components/table.adoc#methods-set-item-click-action[setItemClickAction] -
<<methods-sort,sort>>
