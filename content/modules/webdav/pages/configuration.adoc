= 配置

[[https]]
== 配置 HTTPS

若要对桌面端应用程序进行认证，服务器必须使用 HTTPS。下面是在开发环境设置 HTTPS 的简要说明。

[IMPORTANT]
====
使用自签名的证书仅适合测试。生产环境的应用程序必须使用由信任机构颁发的 SSL 证书。
====

[[keystore-file]]
=== 创建 Keystore 文件

. 使用 JDK 提供的 https://docs.oracle.com/en/java/javase/11/tools/keytool.html[keytool 工具^] 生成 Keystore 文件：
+
[source,text]
----
keytool -genkey -keyalg RSA -alias localhost -keystore localhost.jks -validity 365 -keysize 2048
----
+
会要求你设置 keystore 的密码和名称。记录输入的密码和名称。

. 从 keystore 导出证书：
+
[source,text]
----
keytool -export -keystore localhost.jks -storepass <password> -alias localhost -file localhost.cer
----
+
使用第一步输入的密码替换 `<password>`。

. 在操作系统注册并信任证书。
+
* Windows 操作系统：
+
1. 按下 `Win + R` 打开 *Run* 对话框，输入 `"certmgr.msc"` 并回车，打开 *Certificate Manager*。

2. 在 *Certificate Manager* 左侧的面板中，展开 *受信任的根证书颁发机构* 文件夹。

3. 右键点击文件夹并选择 *所有任务 > 导入...*，打开 *证书导入向导*。

4. 在 *证书导入向导* 中，点击 *下一步*，然后选择证书文件点击 *下一步*。

5. 选择导入至 *受信任的根证书颁发机构* 点击 *下一步*。

6. 检查信息正确并点击 *完成*。

7. 此时会显示一个导入成功的提示，关闭导入向导。
+
完成这些步骤后，证书会注册成功并收系统信任。
* macOS：
1. 在 Finder（访达）中双击 `localhost.cer` 文件。会自动打开 *Keychain Access（钥匙串访问）* 应用程序。
2. 在 *Certficates（证书）* 标签页找到第一步输入名称下的证书。
3. 双击证书，并选择 *Trust（信任） -> When using this certificate: Always Trust（使用此证书时：始终信任）*。

=== 生成可信证书

某些情况下，例如在最新的 LibreOffice 和 Firefox 版本中打开 WebDAV 文件，可能无法使用自签名证书。信任证书可以从 SSL 提供商处获得，也可以使用 `certbot` 生成。在开发阶段，可以发布自己的根证书，并用来对开发服务器的证书进行签名。简单起见，我们建议使用 `mkcert` 工具生成/维护证书。如果对 HTTPS 警告和限制不在意，可以跳过此部分。

. 从这个仓库安装 `mkcert`： https://github.com/FiloSottile/mkcert[https://github.com/FiloSottile/mkcert]。可以使用源码构建（需要安装 golang）并将二进制文件复制到 `/usr/local/bin` 或使用其提供的二进制文件。

. 在 path 中有 `mkcert` 后，可以生成并安装根证书：

    mkcert -install

. 切换到到 keystore 目录，并为开发服务器创建签名证书：

    mkcert -pkcs12 localhost 127.0.0.1 ::1

. 为项目创建带有证书的 `.jks` keystore 文件：

    keytool -importkeystore -srckeystore localhost+2.p12 -srcstoretype pkcs12 -destkeystore localhost.jks

[[configuring-server]]
=== 服务配置

本节介绍当从 IDE 运行应用程序或者用可执行 JAR 运行时，如何使用上一节生成的证书。

. 创建 `src/main/resources/<base-package>/keystore` 目录，并将 `localhost.jks` 复制到该目录。

. 在 `application.properties` 文件设置下列应用程序属性，用真实值替换 `<base-package>` 和 `<password>`：
+
[source,properties,indent=0]
----
# 启用 HTTPS
server.ssl.enabled=true
# keystore 的格式
server.ssl.key-store-type = JKS
# 包含证书的 keystore 路径
server.ssl.key-store = classpath:<base-package>/keystore/localhost.jks
# 生成 keystore 的密码
server.ssl.key-store-password = <password>
# 证书的映射别名
server.ssl.key-alias = localhost

# 服务端口
server.port = 8443
----
+
[NOTE]
====
keystore 路径的 `<base-package>` 部分（`server.ssl.key-store` 配置中）应该是由斜杠分隔的路径：
----
server.ssl.key-store = classpath:com/example/demo/keystore/localhost.jks
----
====
. 打开主应用程序类，并修改 `printApplicationUrl()` 方法。由于配置了 HTTPS，URL 需要修改为 `https://`：
+
[source,java,indent=0]
----
@EventListener
    public void printApplicationUrl(final ApplicationStartedEvent event) {
        LoggerFactory.getLogger(DemoApplication.class).info("Application started at "
                + "https://localhost:"
                + environment.getProperty("local.server.port")
                + Strings.nullToEmpty(environment.getProperty("server.servlet.context-path")));
    }
----

[[maintenance]]
== 维护作业

WebDAV 扩展组件包含几个维护作业，如下所述。如需定期执行这些作业，请在项目中 xref:quartz:index.adoc#installation[安装] Quartz 扩展组件。

[[expired-lock-cleaning-job]]
=== ExpiredLockCleaningJob

删除过期的 xref:webdav-documents.adoc#lock-unlock[锁] 对象。默认每 2 小时运行一次。

如需修改任务调度，请使用 xref:webdav:webdav-properties.adoc#jmix.webdav.expired-lock-cleaning-cron[jmix.webdav.expired-lock-cleaning-cron] 应用程序属性。

[[webdav-document-versions-cleaning-job]]
=== WebdavDocumentVersionsCleaningJob

删除没有链接任何文档的 `WebdavDocumentVersion` 实例。默认每月运行一次。

如需修改任务调度，请使用 xref:webdav:webdav-properties.adoc#jmix.webdav.document-versions-cleaning-cron[jmix.webdav.document-versions-cleaning-cron] 应用程序属性。

[[security]]
== 权限配置

文档的访问权限通过 xref:security:resource-roles.adoc[资源] 和 xref:security:row-level-roles.adoc[行级] 角色配置。

[[predefined-roles]]
=== 预定义角色

WebDAV 扩展组件提供了两个默认资源角色：

* *WebDAV: minimal access* - 使用 WebDAV 功能的基础角色。
* *WebDAV: view document browser* - 提供访问 xref:webdav-documents.adoc[WebDAV 文档] 视图的权限。

// [[row-level-restrictions]]
// === Restricting Access to Documents
//
// Suppose that some group of users should be able to edit only the documents created by themselves. Below is an example of how to do it using row-level roles.
//
// //The following example shows how to restrict access to a particular group of users. Suppose that there is a row-level role called `Users`. It is required to configure this row-level role so that only document authors can edit documents and document versions.
//
// . Create a row-level role at runtime using UI screens available at *Administration → Row-level roles.*
// . Create a row-level xref:security:row-level-roles.adoc#predicate-policy[predicate policy] for the `UPDATE` action and `WebdavDocument` entity.
// . Define a Groovy script for the created policy:
// +
// [source,groovy,indent=0]
// ----
// import io.jmix.core.security.CurrentAuthentication
//
// def authBean = applicationContext.getBean(CurrentAuthentication)
//
// return {E}.createdBy.equals(authBean.user.username)
// ----
// . Assign the role to the users.
//
// The system will check whether the current user is a document author. If it is not the case, the user will not be allowed to edit a document, and the `Access denied` message will be displayed.
//
// The *OK* button intended to save document versions will be inactive. The document itself will be opened in read-only mode.
