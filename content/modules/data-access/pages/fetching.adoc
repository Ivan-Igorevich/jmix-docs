= Извлечение данных

В данном разделе описывается, как и когда данные извлекаются в память в процессе загрузки сущностей из базы данных.

Сущности модели данных часто имеют ссылки на другие сущности, например, `Order` имеет связанный `Customer` в атрибуте `Order.customer`. Jmix позволяет вам обращаться к связанным сущностям путем навигации по ссылочным атрибутам в коде Java с помощью геттеров, например `order.getCustomer().getName()`, и в data-aware компонентах UI с помощью точечной нотации, например `order.customer.name`.

В целом, существует две стратегии загрузки связанных сущностей:

* _Жадная загрузка (eager fetching)_ означает, что связанная сущность загружается из базы данных вместе с корневой сущностью.
* _Ленивая загрузка (lazy loading)_ означает, что связанная сущность автоматически загружается из базы данных при обращении к ссылочному свойству.

[[lazy-loading]]
== Ленивая загрузка

Jmix поддерживает ленивую загрузку ссылок для объектов JPA, загруженных с помощью xref:data-manager.adoc[DataManager]. Это означает, что если вы использовали `DataManager` или xref:flow-ui:data/data-loaders.adoc[загрузчики данных UI] для загрузки сущности, вы можете обратиться к ее ссылочным атрибутам, чтобы получить связанные сущности, и Jmix по требованию загрузит их из базы данных. Этот процесс является рекурсивным, поэтому вы можете просмотреть весь граф объектов, просто обратившись к ссылочным атрибутам.

Например:
[source,java,indent=0]
----
include::example$/ex1/src/main/java/dataaccess/ex1/bean/OrderService.java[tags=lazy-loading]
----
<1> Загрузка сущности `Customer`.
<2> Загрузка коллекции сущностей `OrderLine`.
<3> Загрузка сущности `Product`.

Ленивая загрузка очень удобна, но зачастую не обеспечивает наилучшую производительность. Это особенно верно при работе с коллекциями сущностей. Посмотрите на метод `getProductNames()` в примере выше: он загружает коллекцию строк заказа, а затем для каждой строки отправляется в базу данных за соответствующим продуктом. Это приводит к N+1 запросам, где N - количество строк заказа в коллекции.

Другим примером проблемы N+1 является ленивая загрузка на экране браузера сущностей. Например, если вы загружаете список заказов и для каждого заказа показываете связанного клиента, вам необходимо определить столбец таблицы пользовательского интерфейса, привязанный к атрибуту `Order.customer`. Затем при ленивой загрузке вы получите 1 запрос базы данных для заказов, затем N запросов для клиентов, где N - размер страницы таблицы заказов.

Если вы столкнулись с проблемами с производительностью при ленивой загрузке, используйте жадную загрузку с <<fetch-plan, фетч-планами>>, как описано в следующем разделе.

[[fetch-plan]]
== Фетч-планы

_Фетч-план (fetch plan)_ определяет, какой граф объектов должен быть жадно загружен из базы данных в конкретной операции. Его можно использовать в xref:data-manager.adoc[DataManager] и xref:flow-ui:data-components.adoc[компонентах данных] UI для оптимизации производительности, а также в xref:rest:index.adoc[REST API] для определения формы возвращаемых данных без создания отдельного набора DTO.

TIP: Фетч-планы полностью совместимы с ленивой загрузкой связанных сущностей. Это означает, что вы можете загрузить некоторую часть графа с помощью фетч-плана, а затем лениво загружать другие связанные сущности, переходя по ссылкам.

[[fetch-plan-example]]
=== Пример использования фетч-плана

Давайте рассмотрим несколько вариантов использования фетч-плана с сущностью `Order` и связанных с ней сущностями, которые составляют следующую модель данных:

image::fetching-diagram-1.svg[align="center"]

. Предположим, нам нужно отобразить список заказов на экране просмотра, а таблица UI должна содержать столбцы `number`, `date`, `amount` и `customer.name`. Тогда оптимальной была бы загрузка следующего графа объектов:
+
--
image::fetching-diagram-2.svg[align="center"]

Чтобы жадно загрузить этот граф, определим в экране следующий фетч-план:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/dataaccess/ex1/screen/order/order-browse.xml[tags=fetch-plan]
----

В результате фреймворк выполняет один SQL-запрос с соединением таблиц заказов и клиентов, и связанные клиенты жадно загружаются вместе с заказами. Это устраняет проблему N+1, которая возникла бы, если клиенты загружались бы лениво.

Кроме того, поскольку фетч-план определяет отдельные локальные атрибуты, результирующий набор SQL включает только эти атрибуты и опускает поле `customer.email`. Это поле не извлекается из базы данных и не использует память сервера в экземпляре сущности. Это хорошо для производительности, но с такими <<partial-entities,частично загруженными>> экземплярами сущностей необходимо обращаться осторожно.

[NOTE]
====
При создании экрана для сущности с помощью Studio мастер создания экрана по умолчанию предлагает фетч-план `_base` для корневой сущности и выбранных связанных сущностей, поэтому определение фетч-плана будет выглядеть несколько иначе:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/dataaccess/ex1/screen/order/order-browse-1.xml[tags=fetch-plan]
----

`_base` – это встроенный фетч-план (подробнее об этом <<built-in-fetch-plans,см. ниже>>), при котором всегда загружаются все локальные атрибуты сущностей.
====
--

. Теперь рассмотрим случай редактирования заказа. Экран редактора сущности должен позволять пользователю изменять атрибуты заказа, выбирать клиента, а также создавать и редактировать строки заказа, выбирать продукты для них и пересчитывать общую сумму заказа. В этом случае нам нужны почти все сущности, но некоторые атрибуты связанных сущностей можно опустить:
+
--
image::fetching-diagram-3.svg[align="center"]

Если вы используете мастер создания экранов Studio и выбираете связанные сущности с фетч-планом по умолчанию `_base`, в экране создается следующий фетч-план:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/dataaccess/ex1/screen/order/order-edit.xml[tags=fetch-plan]
----

TIP: Вы можете выбрать  для сущностей отдельные локальные атрибуты вместо фетч-плана `_base`, но мы не рекомендуем использовать его для экрана редактора. Подробнее о частично загруженных объектах см. ниже.
--

[[partial-entities]]
=== Частичные сущности

Если вы используете фетч-план, который не включает некоторые локальные атрибуты сущности, сущность будет загружена частично. Атрибуты, отсутствующие в фетч-плане, будут пустыми в экземпляре сущности. Если вы обращаетесь к такому атрибуту, вызывая его геттер/сеттер или используя его в компоненте UI, фреймворк выбрасывает исключение, подобное такому:

[source,text]
----
java.lang.IllegalStateException: Cannot get unfetched attribute [foo] from
    detached object com.company.entity.Bar-7f9e689a-fe04-8b5f-35db-5fa51a9a9d71 [detached].
----

Рекомендуется использовать частичные фетч-планы в редких случаях, когда есть реальные преимущества в производительности от загрузки не всех атрибутов. Обычно это происходит, когда сущность "широкая" (десятки или сотни атрибутов), и загружаются большие списки сущностей со множеством ссылок, что увеличивает объем ненужных данных для извлечения.

Если вы загружаете одну корневую сущность или небольшую коллекцию, лучше положиться на <<lazy-loading,ленивую загрузку>> или использовать фетч-план, основанный на `_base`, чтобы избежать проблемы N+1. В противном случае, с одной стороны, выигрыш в производительности от частичных сущностей будет незначительным; с другой стороны, вы можете столкнуться с проблемами, если случайно обратитесь к неизвлеченным атрибутам.

NOTE: Идентификатор сущности и атрибуты xref:data-model:entities.adoc#versioned-trait[Version] загружаются всегда, независимо от фетч-плана.

[[built-in-fetch-plans]]
=== Встроенные фетч-планы

Jmix предоставляет три встроенных фетч-плана для каждой сущности:

* Фетч-план `_local` включает в себя все локальные атрибуты (непосредственные атрибуты, которые не являются ссылками).
* Фетч-план `_instance_name` включает в себя все атрибуты, формирующие xref:data-model:entities.adoc#instance-name[имя экземпляра]. Это могут быть локальные атрибуты и ссылки. Если для сущности не указано имя экземпляра, этот фетч-план будет пуст.
* Фетч-план `_base` включает в себя все атрибуты фетч-планов `_local` и `_instance_name`, плюс embedded-ссылки.

TIP: Используйте фетч-план `_base`, пока не столкнетесь с проблемой с производительностью при загрузке больших списков "широких" сущностей. Это избавит вас от проблем с неизвлеченными атрибутами, описанными в разделе <<partial-entities,Частичные сущности>>.

[[creating-fetch-plans]]
=== Создание фетч-планов

Вы можете определить собственные фетч-планы следующими способами:

. Как встроенные фетч-планы в дескрипторах экранов UI. Это показано на примере <<fetch-plan-example,выше>>.

. Программно в Java.
+
--
Вы можете создать фетч-план с помощью фабрики `FetchPlans` и использовать его в операции `DataManager` следующим образом:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/dataaccess/ex1/bean/OrderServiceTest.java[tags=fetch-plans;fetch-plan-builder]
----

Также вы можете использовать билдер фетч-планов прямо в fluent интерфейсе загрузки `DataManager`:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/dataaccess/ex1/bean/OrderServiceTest.java[tags=fetch-plan-builder-dm]
----

--

. В общем репозитории фетч-планов.
+
--
Вы можете создавать фетч-планы в общем репозитории и использовать их по имени в любом месте проекта также, как <<built-in-fetch-plans,встроенные>>.

Во-первых, создайте `fetch-plans.xml` файл в каталоге `resources/<base package>` и задайте свойство xref:ROOT:app-properties.adoc#jmix.core.fetch-plans-config[jmix.core.fetch-plans-config]. Можно сделать это в Studio, выбрав *New -> Advanced -> Fetch Plan Configuration File* в окне инструментов Jmix.

После создания файла в меню *New -> Advanced* окна инструментов Jmix появится пункт *Fetch Plan*. Он позволяет определить фетч-план с помощью xref:studio:fetch-plan-designer.adoc[дизайнера].

Ниже приведен пример фетч-плана, определенного в `fetch-plans.xml`.

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/dataaccess/ex1/fetch-plans.xml[tags=fetch-plan]
----

Этот фетч-план может использоваться по имени в операции `DataManager`:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/dataaccess/ex1/bean/OrderServiceTest.java[tags=fetch-plan]
----

Другой вариант – извлечь экземпляр фетч-плана из репозитория:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/dataaccess/ex1/bean/OrderServiceTest.java[tags=fetch-plan-repo;fetch-plan-repo-use]
----

--