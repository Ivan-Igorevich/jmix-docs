= Интеграционные тесты

Интеграционный тест предназначен для охвата более широкой области, чем юнит-тест. Он позволяет выполнять код в окружении, близком к нормальному времени выполнения приложения. Когда речь идет об интеграционных тестах, мы имеем в виду тесты, которые запускают полный контекст Spring и взаимодействуют с базой данных, если это необходимо.

TIP: Используйте действие *New → Advanced → Integration Test* в окне инструментов *Jmix*, чтобы быстро создать интеграционный тест с помощью Studio.

В примере ниже мы снова будем тестировать класс `OrderAmountCalculation`, но на этот раз не как изолированный блок (как описано в предыдущем разделе), а в более широком контексте, в котором он используется в приложении. В данном случае существует слушатель событий `EntityChangedEvent` сущностей `OrderLine`. В рамках логики сохранения, слушатель пересчитывает сумму заказа, которому принадлежит строка заказа, с помощью класса `OrderAmountCalculation`:

[source,java,indent=0,title='OrderLineEventListener.java']
----
include::example$/testing-ex1/src/main/java/com/company/demo/app/OrderLineEventListener.java[tags=recalculate-order-amount]
----

В интеграционном тесте `OrderLineEventListener` и `OrderAmountCalculation` могут быть протестированы вместе. Тест создаст заказ и строку заказа и сохранит их в базу данных с использованием API xref:data-access:data-manager.adoc[DataManager]. Это вызовет срабатывание слушателя событий, и сумма заказа будет рассчитана.

[[dependency-injection-in-tests]]
== Инжекция зависимостей в тестах

Интеграционный тест Spring может использовать тот же механизм инжекции зависимостей, что и код приложения. В частности, можно использовать аннотацию `@Autowired` для инжекции бинов в класс теста. В примере ниже `DataManager` инжектируется в класс теста для того, чтобы через него вызвать логику `OrderLineEventListener`:

[source,java,indent=0,title='OrderLineEventListenerTest.java']
----
@SpringBootTest
public class OrderLineEventListenerTest {

    @Autowired
    DataManager dataManager;

    // ...
}
----

Если вам нужно протестировать собственный бин напрямую, вы также можете инжектировать этот бин в класс теста. В следующем примере `CustomerService` инжектируется в класс теста для непосредственного вызова его тестируемых методов:

[source,java,indent=0,title='CustomerServiceTest.java']
----
@SpringBootTest
public class CustomerServiceTest {

    @Autowired
    CustomerService customerService;

    // ...
}
----

[[database-interactions]]
== Взаимодействие с базой данных

Существует две основные причины взаимодействия с базой данных в интеграционном тесте.

Первая - это возможность настройки тестовых данных, необходимых для выполнения тестового случая. Для взаимодействия с базой данных можно использовать обычную для продакшн-кода функциональность Jmix, такую как `DataManager`.

Вторая причина заключается в том, что к базе данных может обращаться логика приложения, выполняемая в тесте.

Давайте рассмотрим пример для обоих этих сценариев:

[source,java,indent=0,title='CustomerServiceTest.java']
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/CustomerServiceTest.java[tags=find-by-email-found]
----
<1> `DataManager` используется в тесте для создания тестового клиента в базе данных.
<2> `CustomerService` используется для выполнения поиска клиентов по электронной почте.

[[test-data-cleanup]]
=== Очистка тестовых данных

В приведенном выше примере `DataManager` сохраняет тестового клиента в базе данных. Поскольку все тесты по умолчанию используют один и тот же экземпляр базы данных, это означает, что эти тестовые данные будут также доступны для следующего теста. Это может вызвать проблемы. Например, предположим, что существует уникальное ограничение на поле адреса электронной почты сущности `Customer`. Если вы напишете тест, который создает клиента с определенным адресом электронной почты, и другой тест, который ищет клиента по адресу электронной почты (предполагая, что его там нет), второй тест не пройдет, потому что он найдет клиента, созданного первым тестом.

Существует несколько способов очистки тестовых данных. Первый - это сохранение ссылок на сущности, созданные во время теста. В приведенном выше примере вы можете сохранить ссылку на созданного в тесте клиента и удалить его после завершения теста с использованием `dataManager.remove(customer)`. Это рабочий подход, но он требует дополнительного кода в тесте. Кроме того, не всегда возможно сохранить ссылку на данные, созданные во время теста. Например, если новая сущность создается в логике приложения, вы скорее всего не сможете получить на нее ссылку в тесте. Кроме того, в случае исключения во время теста код очистки может не выполниться.

Второй вариант - проведение более общей очистки базы данных. В следующем примере `JdbcTemplate` выполняет операцию SQL `DELETE FROM CUSTOMER`, чтобы удалить всех клиентов из базы данных:

[source,java,indent=0,title='CustomerServiceTest.java']
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/CustomerServiceTest.java[tags=cleanup-customer-table]
----
<1> `DataSource` инжектируется для создания экземпляра `JdbcTemplate`.
<2> `@AfterEach` указывает JUnit, что данный метод должен быть выполнен после каждого тестового случая.
<3> Класс Spring `JdbcTestUtils` предоставляет удобный метод для удаления всех данных из таблицы базы данных. См. дополнительную информацию в {spring-framework-doc}/testing/support-jdbc.html[документации Spring testing^].

[[security-context-in-tests]]
== Контекст безопасности в тестах

Jmix позволяет выполнять код от имени определенного пользователя, что часто необходимо для тестирования функциональности, зависящей от ролей и разрешений пользователя. Это можно достичь с использованием xref:security:authentication.adoc#system[SystemAuthenticator].

Давайте рассмотрим пример тестирования метода `CustomerService`, который ведет себя по-разному в зависимости от роли пользователя, выполняющего его:

[source,java,indent=0,title='CustomerService.java']
----
include::example$/testing-ex1/src/main/java/com/company/demo/app/CustomerService.java[tags=customer-service]
----

В этом примере `CustomerService` имеет метод `findCustomerByEmail`, который возвращает сущность клиента, если она найдена. Политики подсистемы безопасности разрешают доступ к данным клиента только для определенных ролей. Это поведение можно протестировать, используя `SystemAuthenticator` для выполнения метода от имени конкретного пользователя:

[source,java,indent=0,title='CustomerServiceTest.java']
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/CustomerServiceTest.java[tags=find-by-email-as-user]
----
<1> Для теста создается новый пользователь без присвоения каких-либо ролей.
<2> `SystemAuthenticator` выполняет тестируемый код от имени только что созданного пользователя.
<3> `CustomerService` выполняет поиск клиентов по электронной почте с контекстом безопасности этого пользователя.

Так как у пользователя нет ролей, сервис возвращает пустой `Optional`.

[[authenticated-as-admin]]
=== AuthenticatedAsAdmin

Вместо того, чтобы устанавливать контекст безопасности в определенных местах теста, можно использовать расширение JUnit `AuthenticatedAsAdmin`, которое автоматически создается в новом проекте Jmix. Оно создает контекст безопасности перед каждым тестом и устанавливает аутентифицированного пользователя в администратора.

[source,java,indent=0,title='CustomerServiceTest.java']
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/CustomerServiceTest.java[tags=authenticated-as-admin]
----

Также можно объединить расширение `AuthenticatedAsAdmin` с `SystemAuthenticator` для выполнения кода теста от имени конкретного пользователя. Аннотировав класс теста, контекст безопасности по умолчанию устанавливается в администратора. Но внутри тест-кейса можно использовать `SystemAuthenticator` для выполнения кода от имени конкретного пользователя.

[[overriding-application-behavior]]
== Изменение поведения приложения

Иногда, даже для интеграционных тестов, необходимо подменить определенные части приложения. В этих случаях можно комбинировать функциональность `@SpringBootTest` с Mockito и подменять определенные бины, но при этом использовать общий контекст Spring.

Давайте рассмотрим `NotificationService`, который в рамках своей бизнес-логики использует API `Emailer` из дополнения xref:email:index.adoc[]. Интеграционный тест для этого сервиса не должен фактически отправлять письма, поэтому функциональность электронной почты должна быть подменена.

[[mock-bean]]
=== @MockBean

Для создания фиктивного объекта бина в интеграционном тесте Spring можно использовать аннотацию `@MockBean`. В следующем примере бин `Emailer` подменяется моком для теста `NotificationService`, описанного выше:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/NotificationServiceTest.java[]
----

Аннотация `@MockBean` заменяет бин в контексте приложения на фиктивный объект. Это позволяет достичь следующего:

. Избежать фактической отправки электронной почты.
. Симулировать сценарий отказа, когда отправка электронной почты не удалась.

[[test-configuration]]
=== @TestConfiguration

В приведенном выше примере аннотация `@MockBean` используется для замены бина `Emailer` фиктивным объектом. Но это не единственный способ заменить бин в контексте приложения. Другой способ - использовать аннотацию `@TestConfiguration`. Эта аннотация задается на классе конфигурации, который используется только для теста. В следующем примере класс тестовой конфигурации заменяет бин `Emailer` на фиктивный объект:

[source,java,indent=0]
----
include::example$/testing-ex1/src/test/java/com/company/demo/app/NotificationServiceWithTestConfigurationTest.java[]
----
<1> Внутренний статический класс, аннотированный `@TestConfiguration`, будет использован Spring при выполнении тестового случая.
<2> Объявлен бин с именем `emailer` типа `Emailer`. Он переопределяет стандартный бин этого типа.
<3> Создается фиктивный экземпляр (мок).
<4> Указывается поведение мока, и настроенный мок возвращается.

Продакшн-код, взаимодействующий с бином `Emailer`, теперь будет использовать фиктивный объект вместо стандартной реализации.
