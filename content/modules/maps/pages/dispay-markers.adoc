= 2. Display Multiple Point Locations as Map Markers

[[add-attr]]
== Adding Attribute to Entity and UI

Let’s add the `location` attribute to the `User` entity:

Double-click on the `User` entity in *Jmix* tool window and select its last attribute (to add the new attribute to the end):

image::new-attr-for-user.png[align="center", width="1046"]

Click *Add* (image:add.svg[]) in the *Attributes* toolbar. In the *New Attribute* dialog, enter `location` into the *Name* field, select `ASSOCIATION` in the *Attribute type* dropdown and `Location` in the *Type* dropdown. Select *One to One* cardinality and check the *Owning Side* flag.

image::location-attr.png[align="center", width="862"]

For one-to-one xref:data-model:entities.adoc#references[reference], Studio suggests to create an inverse attribute in the `Location` entity.

image::create-inverse-attr.png[align="center", width="416"]

Click *Yes* and then *OK* in the next dialog.

Select the `location` attribute and click the *Add to Views* (image:add-attribute-to-screens.svg[]) button in the *Attributes* toolbar:

image::add-attr-to-view.png[align="center", width="431"]

The appeared dialog window will show all views that display the `User` entity. Select the `User.detail` view:

image::add-attr-to-detail.png[align="center", width="561"]

Studio will add the `location` property to `fetchPlan` and the `entityPicker` component to `formLayout` of the `User.detail` view.

Click the *Debug* button (image:start-debugger.svg[]) in the main toolbar.

Before running the application, Studio will generate a Liquibase changelog:

image::changelog-user.png[align="center", width="1036"]

Click *Save and run*.

Studio will execute the changelog, then build and run the application.

Open `++http://localhost:8080++` in your web browser and log in to the application with `admin` / `admin` credentials.

Click on the `Users` item in the `Application` menu.

Click *Create*. The UI control for selecting a location is shown at the bottom of the form:

image::user-with-location-detail.png[align="center", width="790"]

[[create-blank-view]]
== Creating Blank View

If your application is running, stop it using the *Stop* button (image:suspend.svg[]) in the main toolbar.

In the *Jmix* tool window, click *New* (image:add.svg[]) -> *View*:

image::create-blank-view.png[align="center", width="290"]

In the *Create Jmix View* window, select the `Blank view` template:

image::create-view-template.png[align="center", width="776"]

Click *Next*.

On the next step of the wizard, enter:

* *Descriptor name*: `location-lookup-view`
* *Controller name*: `LocationLookupView`
* *Package name*: `com.company.onboarding.view.locationlookup`

Clear *Parent menu item*, as the menu item is not needed for this view.

image::create-blank-view-params.png[align="center", width="776"]

Click *Next* and then *Create*.

Studio will create an empty view and open it in the designer:

image::create-view-designer.png[align="center", width="1386"]

== Setting Up the View Opening

Our new view should open from the user's detail view. For this purpose, the *Location* field is used.

Let's change the Studio-generated `entityPicker` component to the `valuePicker` component. Open `user-detail-view.xml` and find the `entityPicker` component inside the `formLayout`:

[source,xml,indent=0]
----
<layout>
    <formLayout id="form" dataContainer="userDc">
        ...
        <entityPicker id="locationField" property="location">
            <actions>
                <action id="entityLookup" type="entity_lookup"/>
                <action id="entityClear" type="entity_clear"/>
            </actions>
        </entityPicker>
        ...
    </formLayout>
</layout>
----

Change the XML element of the component to `valuePicker` and remove the nested `actions` element.

Select `valuePicker` in the *Jmix UI* hierarchy panel or in the view XML descriptor and click the *Add* button in the inspector panel. Select *Actions -> Action* in the drop-down list.

image::value-picker-actions.png[align="center", width="1100"]

First, select a `New Base Action` and click *OK*.

image::new-base-action.png[align="center", width="492"]

Set the `id` of the action to `select` and `icon` to `vaadin:search`.

image::select-action.png[align="center", width="486"]

Then add a predefined `value_clear` action for `locationField`:

image::add-value-clear-action.png[align="center", width="492"]

Select the `select` action in the *Jmix UI* hierarchy panel or in the view XML descriptor and switch to the *Handlers* tab in the *Jmix Inspector* panel. Generate an `ActionPerformedEvent` handler method:

image::action-performed-event.png[align="center", width="939"]

Add the logic of opening `LocationLookupView` to `ActionPerformedEvent` handler method:

[source,java,indent=0]
----
@Autowired
private DialogWindows dialogWindows; // <1>

@Subscribe("locationField.select")
public void onLocationFieldSelect(final ActionPerformedEvent event) {
    dialogWindows.view(this, LocationLookupView.class).open();
}
----
<1> The xref:flow-ui:opening-views.adoc#dialog-windows[DialogWindows] bean provides a fluent interface for opening views in dialog windows.

Launch the application. Click on the `Users` item in the `Application` menu. Click *Create*. The `User.detail` view will open. Find the *Location* field and click on the (image:search-button.png[width="29"]) *Search* button. The `LocationLookupView` view will open as a dialog.

image::blank-view-as-dialog.png[align="center", width="1112"]

Now you will be able to review the changes taking place on our view.

== Adding Components on LocationLookupView

First, add a field where the current location selected on the map will be displayed. Click *Add Component* in the actions panel, find `entityPicker`, and double-click it. Set the component's properties as below:

[source,xml,indent=0]
----
<entityPicker id="currentLocationField"
              metaClass="Location"
              readOnly="true"
              width="20em"
              label="msg://currentLocationField.label"/>
----

Let's add two `hbox` containers:

. The first contains a list of locations and a map.
. The second contains the *Select* and *Cancel* buttons.

[source,xml,indent=0]
----
<hbox padding="false"
      height="100%"
      width="100%"/>
<hbox id="controlLayout"/>
----

Click *Add Component* in the actions panel and drag and drop `Layouts → VBox` (vertical box) to the first `hbox` element of the *Jmix UI* hierarchy panel. Set the `vbox`'s properties as below:

[source,xml,indent=0]
----
<vbox padding="false" width="25em"/>
----

Then, add a field to select the type of location. Click *Add Component* in the actions panel, find `select`, and drag and drop it to the `vbox`. Set the component's properties as below:

[source,xml,indent=0]
----
<select id="locationTypeField"
        emptySelectionAllowed="true"
        width="20em"
        itemsEnum="com.company.onboarding.entity.LocationType"/>
----

To display the list of locations we will use the `virtualList` component. First, add a data container which will provide a collection of `Location` entities for the virtual list. Click *Add Component* in the actions panel, select the `Data components` section, and double-click the `Collection` item. In the *Collection Properties Editor* window, select `Location` in the *Entity* field and click *OK*:

image::location-collection-container.png[align="center", width="723"]

Studio will create the collection container:

[source,xml,indent=0]
----
    <data>
        <collection id="locationsDc" class="com.company.onboarding.entity.Location">
            <fetchPlan   extends="_base"/>
            <loader id="locationsDl" readOnly="true">
                <query>
                    <![CDATA[select e from Location e]]>
                </query>
            </loader>
        </collection>
    </data>
----

[[loading-data]]
=== Loading Data

To trigger the created loader, add the xref:flow-ui:facets/dataLoadCoordinator.adoc[dataLoadCoordinator] facet.

image::add-data-load-coordinator.png[align="center", width="770"]

The default query will load all `Location` instances, but you need to filter only locations selected in the `locationTypeField` component. So, we declare xref:flow-ui:data/data-loaders.adoc#query-conditions[query conditions] linked with an input field by `DataLoadCoordinator`.

We will use the `component_` prefix in a query condition to refer to the `locationTypeField` component.

Let's configure query conditions declaratively in the `<condition>` XML element:

[source,xml,indent=0]
----
<view xmlns="http://jmix.io/schema/flowui/view"
      title="msg://locationLookupView.title"
      xmlns:c="http://jmix.io/schema/flowui/jpql-condition"> <!--1-->
    <data>
        <collection id="locationsDc" class="com.company.onboarding.entity.Location">
            <fetchPlan extends="_base"/>
            <loader id="locationsDl" readOnly="true">
                <query>
                    <![CDATA[select e from Location e]]>
                    <condition> <!--2-->
                        <c:jpql> <!--3-->
                            <c:where>e.type = :component_locationTypeField</c:where> <!--4-->
                        </c:jpql>
                    </condition>
                </query>
            </loader>
        </collection>
    </data>
----
<1> Adds the JPQL conditions namespace.
<2> Defines the `condition` element inside the query.
<3> Defines a JPQL condition with optional `join` element and mandatory `where` element.
<4> Adds a `WHERE` clause by `type` attribute with the `:component_locationTypeField` parameter.

=== Adding VirtualList

Click *Add Component* in the actions panel, find `virtualList`, and drag and drop it to the `vbox`. Set the component's properties as below:

[source,xml,indent=0]
----
                <virtualList id="locationVirtualList"
                             itemsContainer="locationsDc"
                             minHeight="20em"
                             width="20em"/>
----

At this stage, the view XML should be as below:

[source,xml,indent=0]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<view xmlns="http://jmix.io/schema/flowui/view"
      title="msg://locationLookupView.title"
      xmlns:c="http://jmix.io/schema/flowui/jpql-condition">
    <data>
        <collection id="locationsDc" class="com.company.onboarding.entity.Location">
            <fetchPlan extends="_base"/>
            <loader id="locationsDl" readOnly="true">
                <query>
                    <![CDATA[select e from Location e]]>
                    <condition>
                        <c:jpql>
                            <c:where>e.type = :component_locationTypeField</c:where>
                        </c:jpql>
                    </condition>
                </query>
            </loader>
        </collection>
    </data>
    <layout>
        <entityPicker id="currentLocationField"
                      metaClass="Location"
                      readOnly="true"
                      width="20em"
                      label="msg://currentLocationField.label"/>
        <hbox padding="false"
              height="100%"
              width="100%">
            <vbox padding="false"
                  width="25em">
                <select id="locationTypeField"
                        emptySelectionAllowed="true"
                        width="20em"
                        itemsEnum="com.company.onboarding.entity.LocationType">
                </select>
                <virtualList id="locationVirtualList"
                             itemsContainer="locationsDc"
                             minHeight="20em"
                             width="20em"/>
            </vbox>
        </hbox>
        <hbox id="controlLayout"/>
    </layout>
</view>
----

Let's run the application to see the new feature in action.

image::location-lookup-view.png[align="center", width="1134"]

We will work on the rendering of the locations list further, but for now we will add the map to our view.

[[adding-map]]
=== Adding Map

Place the cursor after the `vbox` element. Click *Add Component* in the actions panel, find the `GeoMap` item and double-click it.

The new `map` element will be created under the `vbox` element in the *Jmix UI* hierarchy panel and in XML. Set the `id`, `height` and `width` attributes as shown below.

[source,xml,indent=0]
----
<maps:geoMap id="map"
             height="100%"
             width="100%"/>
----

Then add a xref:maps:data-binding-map.adoc#adding-tile-layer[tile layer with OsmSource], set a xref:maps:data-binding-map.adoc#setting-map-view[map view] and add a xref:maps:data-binding-map.adoc#adding-data-layer[vector layer with DataVectorSource]. The resulting map should be as below:

[source,xml,indent=0]
----
                <maps:geoMap id="map"
                             height="100%"
                             width="100%">
                    <maps:mapView centerX="0" centerY="51">
                        <maps:extent minX="-15" minY="30" maxX="40" maxY="60"/>
                    </maps:mapView>
                    <maps:layers>
                        <maps:tile>
                            <maps:osmSource/>
                        </maps:tile>
                        <maps:vector id="dataVectorLayer">
                            <maps:dataVectorSource dataContainer="locationsDc"/>
                        </maps:vector>
                    </maps:layers>
                </maps:geoMap>
----

Let's run the application to see the new feature in action.

image::location-lookup-view-with-map.png[align="center", width="1134"]

As we can see, the map does not fit on the view. Therefore, we will change the view size. Add the `@DialogMode` annotation to the `LocationLookupView` controller:

[source,java,indent=0]
----
@Route(value = "LocationLookupView", layout = MainView.class)
@ViewController("LocationLookupView")
@ViewDescriptor("location-lookup-view.xml")
@DialogMode(width = "60em", height = "45em")
public class LocationLookupView extends StandardView {
}
----

Press *Ctrl/Cmd+S* and switch to the running application. Click on the (image:search-button.png[width="29"]) *Search* button next to the *Location* field. The `LocationLookupView` view will open as a dialog with width and height we set earlier.

image::location-lookup-with-map.png[align="center", width="1134"]

On the <<using-markers,next step>> we learn how to use different markers for offices and coworking spaces.

[[add-buttons]]
=== Adding Buttons

Let's add the `Select` button to save the current location for the user and the `Cancel` button to close without saving.

Open the `location-lookup-view.xml` XML descriptor and find the `controlLayout` hbox. Click *Add Component* in the actions panel, drag and drop two buttons into `controlLayout`.

The created buttons should be associated with actions. Specify the `actions` element, which contains nested `action` elements, as it is shown below.

[source,xml,indent=0]
----
include::example$/maps-ex1/src/main/resources/com/company/onboarding/view/locationlookup/location-lookup-view.xml[tags=actions]
----
<1> `select` custom xref:flow-ui:actions/declarative-actions.adoc#attributes[action properties] are defined in-place.
<2> The standard xref:flow-ui:actions/view-actions.adoc#view_close[view close] action.

Generate action performed event using the *Jmix UI* inspector panel → *Handlers* tab.

image::action-select-event.png[align="center", width="815"]

[[select-action-handler]]
Implement the `select` action handler:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/locationlookup/LocationLookupView.java[tags=onSelect]
----
<1> The `close()` method closes the view. It accepts a `StandardOutcome.SELECT` object that can be analysed by the calling code. We will do it xref:maps:interaction-user-location-views.adoc[later].

Set the button ids and associate each button with appropriate action as shown below:

[source,xml,indent=0]
----
include::example$/maps-ex1/src/main/resources/com/company/onboarding/view/locationlookup/location-lookup-view.xml[tags=controlLayout]
----

[[using-markers]]
== Using Custom Markers

Switch to the *Project* tool window and locate different markers for offices and coworking spaces under the `/src/main/resources/META-INF/resources/icons/` directory of the classpath:

image::locate-markers.png[align="center", width="359"]

Open the `LocationLookupView` controller and inject the `GeoMap` component.

[source,java,indent=0]
----
    @ViewComponent
    private GeoMap map;
----

[TIP]
====
You can inject view components and Spring beans using the *Inject* button in the actions panel:

image::inject-map.png[align="center", width="359"]
====

Then add a method to customize the display of markers:

[source,java,indent=0]
----
    private void initGeoMap(){
        StreamResource officeIconResource = new StreamResource("office-marker.png",
                () -> getClass()
                        .getResourceAsStream("/META-INF/resources/icons/office-marker.png"));
        StreamResource coworkingIconResource = new StreamResource("coworking-marker.png",
                () -> getClass()
                        .getResourceAsStream("/META-INF/resources/icons/coworking-marker.png"));

        VectorLayer layer = map.getLayer("dataVectorLayer");

        DataVectorSource<Location> source = layer.getSource(); // <1>
        source.setStyleProvider(location -> new Style() // <2>
                .withImage(new IconStyle()
                        .withScale(0.5)
                        .withAnchorOrigin(IconOrigin.BOTTOM_LEFT)
                        .withAnchor(new Anchor(0.49, 0.12))
                        .withResource(location.getType() == LocationType.OFFICE
                                ? officeIconResource
                                : coworkingIconResource))
                .withText(new TextStyle()
                        .withBackgroundFill(new Fill("rgba(255, 255, 255, 0.6)"))
                        .withPadding(new Padding(5, 5, 5, 5))
                        .withOffsetY(15)
                        .withFont("bold 15px sans-serif")
                        .withText(location.getCity())));
    }
----
<1> Gets `DataVectorSource` linked with `locationsDc`.
<2> Creates a new style that combines an image with a text label for our markers. The image differs depending on the location type.

Click *Generate Handler* button in the top actions panel and select `Controller handlers → InitEvent`:

image::init-event-generate.png[align="center", width="896"]

Click *OK*. Studio will generate a handler method stub. Invoke `initGeoMap()` from the `InitEvent` handler:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/locationlookup/LocationLookupView.java[tags=onInit]
----

Launch the application and open `LocationLookupView`. Test markers appearance for different location types.

image::different-markers.png[align="center", width="1134"]

[[marker-events]]
== Markers Event Handling

When a user selects a marker on the map, the chosen location is set to the *Current location* field. The map zoom level changes and the map is centered on the selected location. The selected marker is placed in the center of the map view.

Open the `LocationLookupView` controller and add the `setMapCenter()` method:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/locationlookup/LocationLookupView.java[tags=setMapCenter]
----

Then find the `initGeoMap()` method and add the following lines to the end of the method body:

[source,java,indent=0]
----
    private void initGeoMap(){
        //...
        source.addGeoObjectClickListener(clickEvent -> {
            Location location = clickEvent.getItem();

            setMapCenter(location.getBuilding().getCoordinate());
        });
    }
----

Let's run the application to see the new feature in action. Now, when you click on the marker, the map zooms in and centers based on the location's coordinates.

image::centered-map.png[align="center", width="1134"]

Now we need to display the selected location in the *Current location* field and make the *Select* button available.

Go back to the `LocationLookupView` controller. Inject `currentLocationField` and the `select` action. Declare the `selected` variable:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/locationlookup/LocationLookupView.java[tags=components;selected]
----

Then add the `onLocationChanged()` method:

[source,java,indent=0]
----
include::example$/maps-ex1/src/main/java/com/company/onboarding/view/locationlookup/LocationLookupView.java[tags=onLocationChanged]
----
<1> Makes the *Select* action available.
<2> Sets the selected location in the *Current location* field.

Invoke `onLocationChanged()` from the `initGeoMap()` method:

[source,java,indent=0]
----
    private void initGeoMap(){
        //...
        source.addGeoObjectClickListener(clickEvent -> {
            //...
            onLocationChanged(location);
        });
    }
----