= События сущностей

Когда вы сохраняете и загружаете сущности с помощью `DataManager`, подсистема доступа к данным Jmix посылает определенные Spring application events. Вы можете создать слушателя событий для выполнения дополнительных действий с сохраненными или загруженными экземплярами сущностей.

[[entity-changed-event]]
== Использование EntityChangedEvent

`EntityChangedEvent` посылается фреймворком при сохранении экземпляра сущности в базе данных. Вы можете обрабатывать событие как внутри транзакции, так и после ее завершения. В обоих случаях на момент события база данных уже содержит измененные данные.

`EntityChangedEvent` содержит тип изменения (создание, обновление или удаление), идентификатор измененной сущности, информацию о том, какие атрибуты были изменены, и старые значения измененных атрибутов. Для ссылочных атрибутов старые значения содержат идентификаторы ссылаемых сущностей.

[[before-commit]]
=== Обработка изменений до коммита

Чтобы обработать `EntityChangedEvent` в текущей транзакции, создайте метод бина с аннотацией `@EventListener`. Метод будет вызван фреймворком сразу после сохранения сущности в базе данных, но до коммита транзакции. Вы можете вносить любые изменения в данные в методе-слушателе, и они будут закоммичены вместе с первоначальными изменениями. Если произойдет исключение, все изменения будут отменены.

В приведенном ниже примере создается связанная сущность для регистрации изменения атрибута. Как измененный `Customer`, так и созданный экземпляр `CustomerGradeChange` будут закоммичены в одной транзакции:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/CustomerEventListener.java[tags=listener-bean;data-manager;before-commit]
----
<1> Определение типа изменения.
<2> Проверка, действительно ли атрибут был изменен.
<3> Получение идентификатора измененной сущности.
<4> Получение старого значения измененного атрибута.
<5> Загрузка нового состояния измененной сущности.

Давайте рассмотрим другой пример. Здесь атрибут `amount` сущности `Order` обновляется всякий раз, когда создается, обновляется или удаляется один из ее экземпляров OrderLine`:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/OrderLineEventListener.java[tags=entity-changed]
----
<1> После удаления сущности больше нельзя загрузить ее экземпляр, поэтому используются старые значения, чтобы получить ссылку на соответствующий `Order`.
<2> Используйте `getOldReference()` и `getOldCollection()` вместо `getOldValue()` для ссылочных атрибутов to-one и to-many.

[[after-commit]]
=== Обработка изменений после коммита

Чтобы обработать `EntityChangedEvent` после сохранения изменений в базе данных и коммита транзакции, создайте метод бина с аннотацией `@TransactionalEventListener`.

Следует иметь в виду, что исключения, выброшенные в слушателе "after commit" не передаются в вызывающий код и не логгируются. Поэтому рекомендуется оборачивать код слушателя в try-catch.

Если вам нужно загрузить или сохранить какие-либо данные в слушателе событий "after commit", всегда начинайте новую транзакцию.

В приведенном ниже примере демонстрируется обработка исключений и загрузка сущности с помощью `DataManager` в отдельной транзакции (см. метод `joinTransaction(false)`):

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/CustomerEventListener.java[tags=listener-bean;logger;data-manager;after-commit]
----

Если вам нужно сохранить сущность в слушателе "after commit", используйте `SaveContext` и его метод `setJoinTransaction(false)`, например:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/CustomerEventListener.java[tags=save-after-commit]
----

Если у вас есть несколько вызовов `DataManager` или других сервисов, которые могут потребовать наличие транзакции, начните новую транзакцию для всего метода, например:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/CustomerEventListener.java[tags=after-commit-tx]
----
<1> `Propagation.REQUIRES_NEW` здесь необходим для запуска новой транзакции.

[[saving-loading-events]]
== Использование EntitySavingEvent и EntityLoadingEvent

`EntitySavingEvent` посылается фреймворком прямо перед сохранением экземпляра сущности в базе данных. В отличие от <<entity-changed-event,EntityChangedEvent>>, которое содержит идентификатор сущности, `EntitySavingEvent` содержит сам экземпляр сущности. Это позволяет изменить состояние экземпляра до его сохранения в полях базы данных.

Это событие имеет метод `isNewEntity()`, возвращающий значение true, если событие посылается для нового экземпляра, который будет внесен в таблицу базы данных.

Слушатель `EntitySavingEvent` может использоваться для инициализации атрибутов сущности перед сохранением в базе данных. Например:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/OrderEventListener.java[tags=saving-event]
----

`EntityLoadingEvent` отправляется фреймворком при загрузке экземпляра сущности из базы данных. Вы можете использовать его для инициализации неперсистентных атрибутов из персистентного состояния.

[CAUTION]
====
Рекомендуется обращаться только к локальным атрибутам сущности, которая поступает в слушатели `EntitySavingEvent` и `EntityLoadingEvent`.

Фреймворк не гарантирует наличие ссылок в слушателе `EntitySavingEvent` и каскадирование событий при загрузке ссылок из слушателя `EntityLoadingEvent`.
====

В приведенном ниже примере слушатели `EntitySavingEvent` и `EntityLoadingEvent` поддерживают зашифрованный атрибут:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/entity/Customer.java[tags=entity;encryption]
----

Когда сущность сохраняется, конфиденциальное содержимое шифруется и сохраняется в базе данных. При загрузке содержимое расшифровывается и возвращается к неперсистентному атрибуту, доступному пользователям:

[source,java,indent=0]
----
include::example$/data-access-ex1/src/main/java/com/company/demo/listener/CustomerEventListener.java[tags=listener-bean;encryption]
----
